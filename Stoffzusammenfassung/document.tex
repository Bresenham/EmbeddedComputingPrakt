%http://de.wikipedia.org/wiki/Hilfe:TeX#Sonderzeichen_in_TeX
%http://www.kubieziel.de/computer/latex-tutorial.html
%http://www.math.uiuc.edu/~hildebr/tex/course/intro2.html
%http://en.wikibooks.org/wiki/LaTeX/Packages/Listings
%Immer document.tex oder main.tex nennen!
%http://latex.mschroeder.net/
%http://stackoverflow.com/questions/741985/latex-source-code-listing-like-in-professional-book
%http://amath.colorado.edu/documentation/LaTeX/reference/faq/bibstyles.pdf
%ftp://tug.ctan.org/pub/tex-archive/info/l2tabu/german/l2tabu.pdf
%http://amath.colorado.edu/documentation/LaTeX/reference/faq/bibstyles.html#styles
%http://www.bibtex.org/SpecialSymbols/de/
%http://amath.colorado.edu/documentation/LaTeX/reference/faq/bibstyles.html#styles
%http://www.bibtex.org/SpecialSymbols/de/
%http://en.wikipedia.org/wiki/Help:Displaying_a_formula
%mit "\input{datei}" wird die Datei "datei.tex" direkt an dieser Stelle eingefügt

\documentclass[
% *** Papiergröße und Seitenteilung ***
	openany,
	german,
	paper=a4,				%A4
					%Bindung links, aufgeschlagen von rechts
	DIV=15,					%Seitenteilung (Anzahl der Teile). Einfach mal damit spielen
							%8..15
	BCOR=-1cm,				%Binderand auf der Innenseite für die Buchbindung
% *** Formatierung/Schriftgröße/Kopf/Fußzeilenoptionen
	8pt,					%Schriftgröße 12pt
	parskip,				%kann mit einer Länge versehen werden um die Absatzgröße
							%einzustellen	
	headsepline,			%Kopfzeile über jeder Seite anlegen
	cleardoublepage=empty,	%Füllseiten sind auch wirklich "leer", also auch ohne
							%Seitennummerierung
	%,chapterprefix
% *** Einträge im Inhaltsverzeichnis (TOC) definieren ***
	bibtotoc,				%Literaturverz/Referenzen
	]{scrreprt}				%KOMA-Vorlage scrrprt

% *** KOMA-Seitenstil Kopfzeilen/Fußzeilen! ***
\setkomafont{disposition}{\rmfamily}
\usepackage{scrpage2} 		%KOMA-Seitenstil
\pagestyle{scrheadings} 	%Seitenstile von scrpage2 {KOMA} aktivieren
\automark[section]{chapter}	%Kapitel innen, Unterkapitel rechts
\clearscrheadings 			%Alle Markierungen auf den Seiten löschen
\ihead{}					%Seitenkopf innen (Bei D.seite l.Seite: r.o. und bei r.Seite:l.o)
\chead{}					%Seitenkopf mitte
\ohead{\headmark}			%Seitenkopf außen 
\ifoot{}					%Seitenfuß innen
\cfoot{}					%Seitenfuß mitte
\ofoot{\pagemark}			%Seitenfuß außen
\setlength{\headheight}{1.1\baselineskip}	%Höhe des reservierten Platzes am Seitenkopf

	
%******************************
%      Sprache und Schrift 
%******************************	
%alles für deutsche Eingabe (sonst keine Umlaute im Sourcecode möglich)   
\usepackage[latin1]{inputenc}
%\usepackage[utf8]{inputenc}
\usepackage[english,ngerman]{babel} 
\usepackage[T1]{fontenc} 	
\usepackage{lmodern}		%bessere Schrift		
%  **  Absätze  **
\parindent 0pt				%Absätze nicht von links einrücken
%Größe dynamisch anpassen, so dass auf die Seite mehr Text geht
%oder aufgeweitet wird, so dass eine angefangene Seite besser gefüllt wird
%\usepackage{setspace}		
\usepackage[onehalfspacing]{setspace}

%******************************
% ALTE SPRACHEN
%******************************
%\usepackage{ibycus4}	%altgriechisch
%\usepackage{etex}
%\usepackage{cjhebrew}		%hebräisch
%\usepackage[english]{betababel}

%\usepackage{palatino}
%\usepackage{latexsym}
%\usepackage{multirow}
%\usepackage{graphicx}


%*********************************
%	Pakete für Index/Glossar/Mathe/...
%*********************************
% ** Mathe/Formeln **
\usepackage{amsmath} 		%TeX-Mathe ermöglichen
% ** Inhaltsverzeichnis **
\usepackage{makeidx}		%wird durch \makeindex eingeleitet und
							%\printindex ausgeführt
\makeindex
% ** Bilder/Grafiken einbinden **
\usepackage{graphicx}		%Graphiken aller Art einbinden, auch eps
\usepackage{float} 			%platziert grafiken besser
% ** Links im PDF werden anklickbar **
\usepackage{hyperref}
% ** Glossar für Begriffsdefinitionen wird erstellt **
\usepackage{nomencl}		%Nomenklatur-Paket für das Glossar verwenden 
\makenomenclature			%wird durch /makenomenclature eingeleitet und mit
							%/printnomenclature ausgeführt
% ** Listings ** ->Sourcecode vorformatiert zitieren -> z Zt auf C++ eingestellt
\usepackage{listings}		%Code-Listings erlauben
\usepackage{color}			%ermöglicht Farbvorgaben, z.B. bei den Listings
\usepackage{courier}
\usepackage{caption}
\usepackage{subfig}
\usepackage{makecell}
\usepackage{titlesec}
\usepackage[default]{gfsneohellenic}
\usepackage{tikz}
\usepackage{tabularx}

%******************
%  RESERVIERT
%******************
%\usepackage{mparhack}		%evtl. notwendig, wenn Ränder buggy
%\input{Kapitel/Zusatz}	%andere Textdateien includieren

%********************************************************
%	Titel usw., auch für das PDF
%********************************************************
\title{Vorlage für eine Bachelorarbeit mit LaTeX}
\author{René Bauer}
\date{9. Mai 2011}
% ** Einträge für das erzeugte PDF **
\hypersetup{
pdfauthor = {René Bauer},
pdftitle = {Vorlage für eine Arbeit mit LaTeX}, 
pdfsubject = {Steuerungsoptimierung},
pdfkeywords = {TeX, LaTeX, pdflatex, Bachelorarbeit, Bachelorthesis, Diplomarbeit},
pdfcreator = {LaTeX with hyperref package},
pdfproducer = {dvips + ps2pdf}	%eigentlich ist es pdflatex
}
\lstset{language=C++,
	basicstyle=\ttfamily,
	keywordstyle=\color{blue}\ttfamily,
	stringstyle=\color{red}\ttfamily,
	commentstyle=\color{green}\ttfamily,
	numbers=none,
	morecomment=[l][\color{magenta}]{\#}
}


\titleformat{\chapter}[display]
{\normalfont\huge}{}{10pt}{\Large}
\titlespacing{\chapter}{0pt}{-125pt}{0pt}

\titleformat{\section}[display]
{\normalfont\huge}{}{-50pt}{\large}

\titleformat{\subsection}[display]
{\normalfont\huge}{}{-50pt}{\large}

%*********************************************
%	Fußnoten durchgehend nummerieren
%*********************************************
% - normalerweise wird je Seite oder Kapitel neu gezählt
\usepackage{chngcntr} 
\counterwithout{footnote}{chapter}

%*********************************************
% Überschriften usw neu benennen
%*********************************************
% hier ist nicht die Namensgebung und Aufnahme der
% Begriffsdefinitionen, hierfür bitte unten nachschauen!
%\renewcommand{\contentsname}{Table of contents}
%\renewcommand{\listfigurename}{List of figures}
%\renewcommand{\figurename}{Figure}
%\renewcommand{\tablename}{Table}
%\renewcommand{\listtablename}{List of tables}

%************************************************
%    HIER BEGINNT DAS EIGENTLICHE DOKUMENT
%************************************************
\begin{document}

%**************************************************************
%   unbedingt eine Seite für die spätere Bindung frei lassen!
%**************************************************************
%\newpage

%******************************************************
%                     Titelblatt
%******************************************************

\chapter{Embedded Systems}
\section{Einführung}
\subsection{Eingebettetes System}
\vspace*{-1.7em}
\begin{tabular}{lc}
	\raisebox{-.5\height}{\includegraphics[scale=0.315]{images/eingebettetes_system.png}} & \makecell[l]{
		$\circ$ integrierte, elektronische Schaltung mit spezifischer Aufgabe,\\
		\hspace*{1em}mit der ein Benutzer nur indirekt in Verbindung kommt\\
		$\circ$ Teil eines Gesamtsystems mit stark beschränkten Ressourcen,\\
		\hspace*{1em}bestehend aus Hard- und Software (teilweise ohne Betriebssystem)\\
		$\circ$ HW/SW-Codedesign z.B. mit \textit{VHDL},\\
		\hspace*{1em}allgemein \textit{tool}- bzw. \textit{modellbasierter} Entwurf\\
		$\circ$ \textit{75 \%} verwenden ein Betriebssystem (Tendenz steigend)\\
		\hspace*{1em}- \textit{25 \%} mit \textit{Main-Loop}
	}
\end{tabular}\\

\begin{tabular}{lc}
	\makecell[l]{
		$\circ$ Ist eine Kombination aus Hard- und Softwarekomponenten, die in einen technischen Kontext\\
		\hspace*{1em}zur \textit{Steuerung}, \textit{Regelung} und \textit{Überwachung} eines Systems eingebunden sind\\
		$\circ$ Es verrichtet vordefinierte Aufgaben, oftmals mit \textit{Echtzeitberechnungs}-Anforderungen\\
		$\circ$ \textbf{Speicherprogrammierbare Steuerung} (SPS): Verwendet zur Fabrikautomatisierung, Verkehrsleitung\\
		$\circ$ \textbf{Standardarchitektur} auf einem PC: Preiswerte Hardware (allerdings oft nicht \textit{industrietauglich})\\
		\hspace*{1em}preiswerte Software, häufig ohne \textit{Echtzeitfaehigkeit}\\
		$\circ$ \textbf{Industrie-PC}: Unterstützt Echtzeitbetriebssysteme
	} & \raisebox{-.5\height}{\includegraphics[scale=0.315]{images/prozessankopplung.png}}
\end{tabular}

\vspace*{-.5em}
\subsection{Definition: \textit{Technischer Prozess}}
\vspace*{-1.7em}
$\circ$ Prozess, in dem Zustandsgrößen durch \textit{technische} Hilfsmittel festgestellt und beeinflusst werden\\
\hspace*{1em}- \textit{Prozess} definiert als Gesamtheit von aufeinander einwirkenden Vorgängen in einem System, durch die Information verändert wird\\
$\circ$ \textit{Sensoren} (z.B. Thermometer, Kamera, Mikrofon) erfassen Zustandsgrößen, \textit{Aktoren} (z.B. Motoren, Relais, Ventile) beeinflussen sie

\vspace*{-.75em}
\subsection{Klassifikation: \textit{Technischer Prozess}}
\vspace*{-1.7em}
$\circ$ \textbf{Fließprozess (Regler):} physikalische Größe mit stückweise kontinuierlichem Wertebereich,\\
\hspace*{1em}ablaufende Vorgänge sind zeit- und ortsabhängig, z.B. chemische Reaktoren, Energieerzeugung in Kraftwerken\\
$\circ$ \textbf{Folgeprozess (State Machine):} Binäre, diskrete Informationselemente werden gemeldet oder ausgelöst,\\
\hspace*{1em}z.B. Ampel- oder Aufzugsteuerung\\
$\circ$ \textbf{Stückprozess (Datenbank):} Informationselemente werden einzeln identifizierbaren Objekten (Stücken) zugeordnet\\
\hspace*{1em}z.B. Transport- oder Ladevorgänge, Fertigung

\vspace*{-.75em}
\subsection{Definition: \textit{Rechenprozess}}
\vspace*{-1.7em}
$\circ$ \textit{Task} als Instanz zur dynamischen Abarbeitung eines Programms zur Berechnung von Ausgabewerten aus Eingabewerten über\\
\hspace*{1em}Umformen, Transportieren oder Speichern von Information

\vspace*{-.75em}
\subsection{Definition: \textit{Kognitiver Prozess}}
\vspace*{-1.7em}
\begin{tabular}{lc}
	\raisebox{-.5\height}{\includegraphics[scale=0.175]{images/kognitiver_prozess.png}} & \makecell[l]{
		$\circ$ Umformen, transportieren oder verarbeiten von Information im menschlichen Bediener\\
		$\circ$ Einflussnahme des Bedieners auf den Rechenprozess über \textit{Man Machine Interface} (MMI)
	}
\end{tabular}

\vspace*{-.75em}
\subsection{Definition: \textit{Steuerungssystem}}
\vspace*{-1.7em}
$\circ$ Umfasst zur Steuerung erforderliche Rechenprozesse sowie deren Hard- bzw. Software\\
$\circ$ Aufgaben:\\
\hspace*{1em}- Erfassen von Zustandsgrößen\\
\hspace*{1em}- Koordinaten \& Überwachung der Prozessabläufe

\vspace*{-.75em}
\subsection{Definition: \textit{Steuerung} und \textit{Regelung}}
\vspace*{-1.7em}
$\circ$ \textbf{Steuerung:} Kein geschlossener \textit{Regelkreis}, Rechenprozess reagiert nicht auf sich ändernde Sensorwerte im technischen Prozess\\
$\circ$ \textbf{Regelung:} Geschlossener \textit{Regelkreis}, Sensor- bzw. Messwerte werden verwendet, um Stellgrößen daraus zu berechnen

\newpage

\vspace*{-3.0em}
\subsection{Self-Hosted-Entwicklung}
\vspace*{-1.7em}
$\circ$ Entwicklungsumgebung und Zielsystem sind identisch (\textit{so wie wir es alle kennen})

\vspace*{-0.5em}
\subsection{Host-Target-Entwicklung}
\vspace*{-1.7em}
$\circ$ \textit{Self-Hosted-Entwicklung} oft nicht möglich da Hardware proprietär oder zu leistungsschwach für Entwicklungsumgebung\\
\begin{tabular}{lc}
	\raisebox{-.5\height}{\includegraphics[scale=0.225]{images/host_target_entwicklung.png}} & \makecell[l]{
		$\circ$ \textbf{Host:} Entwicklungsrechner, enthält \textit{Cross-Compiler}, \textit{Remote-Debugger}, \textit{Target-}Libraries und -Betriebssystem\\
		\hspace*{1em}- \textit{Cross-Compiler:} Erzeugt \textit{Image}, dass eigentliche Applikation sowie\\
		\hspace*{1em}\hspace*{1em}Betriebssystem- und Laufzeitkomponenten + \textit{Startupcode} enthält\\
		\hspace*{1em}- \textit{Remote-Debugger:} Auf dem Host läuft GUI mit \textit{Debug-Info}, über \textit{JTAG} etc. sieht man\\
		\hspace*{1em}\hspace*{1em}den Systemzustand des Targets (\textit{Stack}, \textit{Variablen}belegung) an gewählten \textit{Breakpoints}\\
		\hspace*{1em}- \textit{Ohne} Remote-Debugger: Konsolenausgaben per \textit{printf}, \textit{LED}s blinken lassen\\
		$\circ$ \textbf{Schnittstelle:} Zum \textit{Downloaden} der Applikation auf das \textit{Target} oder fürs \textit{Debugging},\\
		\hspace*{1em}verschiedenste Variationen möglich (z.B. \textit{Ethernet}, \textit{USB}, \textit{JTAG}, \textit{Flash}, ...)\\
		$\circ$ \textbf{Target:} System, für das entwickelt wird\\
		\hspace*{1em}- \textit{Boot-Monitor:} Programm auf dem Target, über das Software geladen und gestartet werden kann,\\
		\hspace*{1em}\hspace*{1em}erfolgt über ähnliche Schnittstellen wie die \textit{Host-Target}-Entwicklung an sich
	}
\end{tabular}

\vspace*{-1.7em}
\subsubsection{Softwareentwicklung in einem \textit{Host-Target} System}
\vspace*{-1.7em}
\begin{tabular}{lc}
	\raisebox{-.5\height}{\includegraphics[scale=0.275]{images/entwicklung_host_target.png}} & \makecell[l]{
		$\circ$ \textbf{Object File:} Symboltabelle\\
		$\circ$ \textbf{Linker:} Symbol-Auflösung und \textit{Relocation}\\
		$\circ$ \textbf{Executable File:} Code \& Daten zur Ausführung, Umsetzung auf virtuellen Speicher\\
		$\circ$ \textbf{Shared object file:} Code und Daten zum (dynamischen) linken mit anderen \textit{object files}\\
		$\circ$ \textbf{Relocatable file:} Code und Daten zum linken mit anderen \textit{object files} um Executable\\
		\hspace*{1em}zu erstellen\\
		$\circ$ \textbf{Dynamic Linker:} Laden von \textit{shared} Libraries
	}
\end{tabular}

\vspace*{-1.7em}
\subsubsection{Tools: \textit{Kernel-Tracer}}
\vspace*{-1.7em}
$\circ$ Zeigt \textit{Signale}, \textit{Task-Zustaende}, \textit{Semaphoren}, \textit{Interrupts}

\vspace*{-1.7em}
\subsubsection{Tools: \textit{Stack-Monitor}}
\vspace*{-1.7em}
\text{$\circ$ Zeigt maximal verfügbarer \textit{Stack} pro \textit{Task}, aktuelle Auslastung und maximale je gemessene Auslastung (\textit{Hochwassermarke}) des Stacks}

\vspace*{-1.7em}
\subsubsection{Weitere Tools}
\vspace*{-1.7em}
$\circ$ Anzeige der Speicherbelegung und \textit{Auslastung} der \textit{CPU}, \textit{Memory-Leak-Detection}, \textit{Code-Coverage}

\newpage

\vspace*{-2.9em}
\section{Echtzeitbetrieb}
\vspace*{-.5em}
\subsection{Kriterien für Echtzeitsysteme}
\vspace*{-1.75em}
\begin{tabular}{lc}
	\raisebox{-.5\height}{
		\begin{tikzpicture}[scale=0.67]
			\coordinate (R) at (0,0);
			\coordinate (B) at (3.5,0.01);
			\coordinate (C) at (4.1,0.01);
			
			\draw[->] (-.5,0) -- (4.2,0) node[right] {$t$};
			\draw[->] (0,-.5) -- (0,4.2) node[above] {$Auslastung$};
			\draw[-, line width=0.25mm]  (3,-.5) -- (3,4);
			\node[] at (4.67, -.5) {Echtzeitschranke};
			
			\draw[-] (R) to[out=60,in=130, distance=3cm ] (B);
			\node[] at (1.75,2.2) {Schneller PC};
			
			\draw[-] (R) to[out=40,in=140, distance=3cm ] (C);
			\node[] at (5.25,0.75) {Langsamer PC};
		\end{tikzpicture}
		} & \makecell[l]{
		$\circ$ Schnelligkeit bzw. Geschwindigkeit ist \textbf{nicht} wichtig im Kontext einer harten Echtzeitschranke\\
		\hspace*{1em}ein schnellerer PC ist zwar häufiger vor der Schranke fertig, aber eben auch nicht zu 100\%\\
		$\circ$ Wichtig dagegen sind:\\
		\hspace*{1em}- Pünktlichkeit (\textit{Ober- und Untergrenze}) bzw. Rechtzeitigkeit (\textit{Nur Obergrenze}) (\textit{timeliness})\\
		\hspace*{1em}- Verfügbarkeit\\
		\hspace*{1em}- Determinismus (bei gleicher Eingabe im gleichen Zustand liefert das System immer die\\
		\hspace*{1em}\hspace*{1em}gleiche Ausgabe)\\
		$\circ$ Verletzungen von Zeitbedingungen ggf. katastrophal (fristgerechte Bearbeitung von Anforderungen\\
		\hspace*{1em}aus einem technischen Prozess)
	}
\end{tabular}

\vspace*{-.5em}
\subsection{Vorbedingungen für Echtzeitbetrieb}
\vspace*{-1.7em}
$\circ$ Verarbeitungszeit von Aufgaben berücksichtigen, bei mehreren Aufgaben Reihenfolge der Abarbeitung planen\\
$\circ$ Reihenfolge entscheidend für fristgerechte Ergebnisse\\
$\circ$ Priorität von Aufgaben gemäß ihrer Wichtigkeit als Planungsgrundlage\\
$\circ$ Unterbrechung einer Aufgabe muss durch einen Prozess zur Bearbeitung höher-priorer Aufgaben möglich sein\\
\hspace*{1em}$\Rightarrow$ Formaler Rahmen zum Nachweis schritthaltender Verarbeitung

\vspace*{-1em}
\subsection{Echtzeitbedingung: Auslastung}
\vspace*{-1.7em}
\begin{tabular}{lc}
	\raisebox{-.5\height}{\includegraphics[scale=0.325]{images/auslastung.png}} & \makecell[l]{
		$\circ$ $t_V$ := Verarbeitungszeit\\
		$\circ$ $t_P$ := Prozesszeit, Abstand zwischen zwei Anforderungen (\textit{Jobs})\\
		\hspace*{1em}desselben Typs, wenn $t_P$ konstant handelt es sich um einen\\
		\hspace*{1em}\textit{zyklischen} bzw. \textit{periodischen} Prozess\\
		$\circ$ $\rho = \frac{t_V}{t_P}$ := Auslastung\\
		\hspace*{1em}- $\rho_A = \frac{t_{VA}}{t_{PA}}$\\
		\hspace*{1em}- $\rho_B = \frac{t_{VB}}{t_{PB}}$\\
		\hspace*{1em}- $\rho_{A+B} = \frac{t_{VA}}{t_{PA}} + \frac{t_{VB}}{t_{PB}}$\\
		$\circ$ $\rho = \sum_{i = 0}^{n}\frac{t_Vi}{t_Pi}$ := Gesamtauslastung bei $n$ Prozessen
	}
\end{tabular}
$\circ$ \textbf{1. \textit{Echtzeitbedingung:}} Gesamtauslastung aller Prozesse $\leq$ 1 $\Leftrightarrow$ $\rho = \sum_{i = 0}^{n}\frac{t_Vi}{t_Pi} \leq 1$

\vspace*{-1.7em}
\subsubsection{Art von Rechenprozessen}
\vspace*{-1.7em}
$\circ$ \textit{zyklisch:} konstanter Abstand zwischen zwei Anforderungen\\
$\circ$ \textit{azyklisch:} Keine Untergrenze zwischen zwei Nachrichten, kommen beliebig (\textit{gefaehrlich})\\
$\circ$ \textit{sporadisch:} ähnlich wie \textit{azyklisch} aber mit Untergrenze zwischen zwei Nachrichten (z.B. \textit{Netzwerktreiber})

\vspace*{-1em}
\subsection{Echtzeitbedingung: Pünktlichkeit}
\vspace*{-1.7em}
\begin{tabular}{lc}
	\raisebox{-.5\height}{\includegraphics[scale=0.325]{images/puenktlich.png}} & \makecell[l]{
		$\circ$ Aufgabe darf nicht vor spezifizierten Zeitpunkt $t_{Zmin}$ erledigt sein(meist unwichtig oder \textit{trivial})\\
		$\circ$ Aufgabe muss spätestens bis Zeitpunkt $t_{Zmax}$ erledigt sein (Rechtzeitigkeit)\\
		$\circ$ Verbleibende Reaktionszeit: $t_R = t_V + t_W$ (Verarbeitungszeit + Wartezeit)\\
		\hspace*{1em}\textit{Wartezeit} := Zeit, bis Rechenkern frei ist
	}
\end{tabular}
$\circ$ \textbf{2. \textit{Echtzeitbedingung:}} Um Aufgaben rechtzeitig zu erledigen, muss die Reaktionszeit zwischen der minimal\\
\hspace*{1em}und maximal zulässigen Reaktionszeit liegen: $t_{Zmin} \leq t_{Rmin} \leq t_R \leq t_{Rmax} \leq t_{Zmax}$

\newpage

\vspace*{-2.5em}
\subsection{Harte und weiche Echtzeit}
\vspace*{-1.7em}
\begin{tabular}{lc}
	\raisebox{-.5\height}{
		\begin{tikzpicture}[scale=0.75]
			\coordinate (A) at (1,0);
			\coordinate (B) at (0,1);
			\coordinate (C) at (3,0);
			\coordinate (D) at (4,1);
			\coordinate (E) at (1,3);
			\coordinate (F) at (3,3);
			\coordinate (G) at (.25,3);
			\coordinate (H) at (3.75,3);
			
			\draw[->] (-.5,0) -- (4.2,0) node[right] {$t$};
			\draw[->] (0,-.5) -- (0,4.2) node[above] {$Kosten$};
			
			\draw[-] (A) node[below] {$t_{Zmin}$} -- (B);
			\draw[-] (C) -- (D)node[right] {Weiche Echtzeit};
			
			\draw[-, dotted] (A) -- (E);
			\draw[-, dotted] (C) node[below] {$t_{Zmax}$} -- (F) node[left] {$Deadline$};
			
			\draw[-] (A) to[out=95, in=-60] (G);
			\draw[-] (C) to[out=85, in=-120] (H) node[right] {Harte Echtzeit};
		\end{tikzpicture}
	} & \makecell[l]{
		$\circ$ \textit{Harte} Echtzeit: Verletzung der Rechtzeitigkeit hat \textit{katastrophale} Folgen\\
		\hspace*{1em}(z.B. Airbag, Herzschrittmacher)\\
		$\circ$ \textit{Weiche} Echtzeit: Schlechteres Ergebnis (z.B. \textit{ruckelnde} Videowiedergabe, GPS-Latenz)\\
		\hspace*{1em}$\Rightarrow$ Häufig \textit{Graubereich}\\
		$\circ$ \textit{Kostenfunktion:} Kosten \textit{explodieren} bei Überschreitung der Echtzeitschranke (\textit{Deadline})\\
		\hspace*{1em}im Falle von Harter Echtzeit, bei Weicher Echtzeit steigen Kosten nur \textit{linear} an
	}
\end{tabular}

\vspace*{-1em}
\begin{tabular}{lc}
	\makecell[l]{
		$\circ$ \textit{Nutzenfunktion:} Ergebnisse außerhalb des Intervalls $[t_{Zmin}, t_{Zmax}]$ haben bei Harter Echtzeit\\
		\hspace*{1em}nahezu \textit{keinen} Nutzen mehr, bei Weicher Echtzeit ungefähr \textit{lineare} Ab- bzw. Zunahme
	} &
	\raisebox{-.5\height}{
		\begin{tikzpicture}[scale=0.75]
			\coordinate (A) at (0,0.1);
			\coordinate (B) at (1,0.1);
			\coordinate (C) at (1,3);
			\coordinate (D) at (3,0.1);
			\coordinate (E) at (3,3);
			\coordinate (F) at (4,0.1);
			
			\draw[->] (-.5,0) -- (4.2,0) node[right] {$t$};
			\draw[->] (0,-.5) -- (0,4.2) node[above] {$Nutzen$};
			
			\draw[-, line width=0.275mm] (A) -- (B) node[below] {$t_{Zmin}$};
			
			\draw[-, line width=0.275mm] (B) -- (C);
			\draw[-, line width=0.275mm] (D) node[below] {$t_{Zmax}$} -- (E) node[left] {$Deadline$};
		
			\draw[-, line width=0.275mm] (D) -- (F);
			
			\draw[-] (A) to[out=53, in=-95] (C);
			\draw[-] (E) to[out=275, in=127] (F);

			
			\node[rotate=90] at (.3, 2.125) {Weiche Echtzeit};
			\node[rotate=90] at (3.75, 2.125) {Weiche Echtzeit};
			\node[rotate=45] at (2, 1.25) {Harte Echtzeit};
			
		\end{tikzpicture}
	}

\end{tabular}


\newpage


\vspace*{-2.5em}
\section{Echtzeitbetriebssysteme}
\vspace*{-.5em}
\subsection{Aufgaben und Anforderungen}
\vspace*{-1.7em}
$\circ$ Steuern und Überwachen: Ausführung der Benutzerprogramme \& Verteilung der Betriebsmittel (Speicher, Prozessor, Dateien)\\
$\circ$ Stellt dem Benutzer die Sicht einer einfacher als die Hardware zu bedienenden \textit{virtuellen Maschine} zur Verfügung\\
\hspace*{1em}- Aus Sicht des Benutzers steht der Rechner ihm allein zur Verfügung\\
\hspace*{1em}- Einfacher, standardisierter Zugriff auf \textit{Ressourcen} (Speicher, Geräte, Dateien per Gerätetreiber, Dateisystem, Speichermanagement)\\
$\circ$ \textbf{Zeitverhalten}\\
\hspace*{1em}- Schnelligkeit (bei einem \textit{RTOS} insbesondere Realisierung kurzer Antwortzeiten)\\
\hspace*{1em}- Zeitlicher Determinismus (Speicherverwaltung und Garbage Collection sind problematisch)\\
\hspace*{1em}\hspace*{1em}$\star$ Scheduling, IPC und Synchronisation\\
\hspace*{1em}\hspace*{1em}$\star$ Angabe und Einhalten von Zeitbedingungen, Bereitstellen von \textit{Zeitdiensten}\\
$\circ$ \textbf{Geringer Ressourcenverbrauch}\\
\hspace*{1em}- Hauptspeicher \& Prozessorzeit\\
$\circ$ \textbf{Zuverlässigkeit \& Stabilität}\\
\hspace*{1em}- Programmfehler dürfen Betriebssystem und andere Programme \textit{nicht} beeinflussen\\
\hspace*{1em}- Linux: Treiber \& Kernelmodule laufen im \textit{Kernel}-Adressraum\\
\hspace*{1em}- QNX: Mikrokernel-Architektur: sogar Treiber haben \textit{eigenen} Adressraum\\
$\circ$ \textbf{Sicherheit}\\
\hspace*{1em}- Datei- und Zugangsschutz\\
$\circ$ \textbf{Portabilität, Flexibilität und Kompatibilität von Systemkomponenten}\\
\hspace*{1em}- Erweiterbarkeit, Einhalten von Standard (z.B. \textit{POSIX})\\
\hspace*{1em}- Möglichkeit für andere Betriebssysteme, geschriebene Programme zu portieren (anpassen, übersetzen, ausführen)\\
$\circ$ \textbf{Skalierbarkeit}\\
\hspace*{1em}- Hinzunehmen oder Weglassen von Betriebssystem-Komponenten möglich machen\\
\hspace*{1em}- Geringer Programm- und Datenspeicherbedarf bei kleinen Anwendungen (\textit{Footprint})\\
\hspace*{1em}- Komfort und umfassende Funktionalität bei großen Anwendungen

\vspace*{-.5em}
\subsection{Aufbau und Struktur}
\vspace*{-1.7em}
\begin{tabular}{lc}
	\raisebox{-.5\height}{\includegraphics[scale=0.4]{images/betriebssystemkern.png}} & \makecell[l]{
		$\circ$ Ein \textit{Betriebssystem} besteht aus aufbauenden \textit{Systemkomponenten}\\
		\hspace*{1em}(Dienstprogramme, Werkzeuge) und einem \textit{Betriebssystemkern}\\
		$\circ$ $(1)$: Hardware-\textit{Interrupt}\\
		$\circ$ $(2)$: Software-Interrupt (\textit{Systemcall})\\
		$\circ$ $(3)$: Hardware-Interrupt (während eines Systemcalls)\\
		$\circ$ $(4)$: Hardware-Interrupt (\textit{Scheduler} wird aufgerufen)\\
		$\circ$ $(5)$: Scheduler übergibt CPU einem Task auf \textit{User}-Ebene\\
		$\circ$ Betriebssystem-Dienste werden fast bei jedem Betriebssystem über\\
		\hspace*{1em}Software-Interrupts (\textit{Supervisor Call} / Systemcall) angefordert
	}
\end{tabular}


\newpage


\vspace*{-2.5em}
\subsection{Prozessmanagement}
\vspace*{-1.7em}
\textbf{Unterbrechung \textit{ohne} Betriebssystem}\\
\vspace*{-1.7em}
\begin{tabular}{lc}
	\raisebox{-.5\height}{\includegraphics[scale=0.4]{images/unterbrechung_ohne_bs.png}} & \makecell[l]{
		$\circ$ $(1)$: CPU arbeitet Programm ab\\
		$\circ$ $(2)$: Interrupt während der Programmabarbeitung:\\
		\hspace*{1em}- Abarbeitung des aktuellen Befehls beenden\\
		\hspace*{1em}- Befehlszähler und Registerinhalte auf den Stack legen\\
		\hspace*{1em}- Befehlszähler auf \textit{Interrupt Service Routine} (ISR) legen\\
		$\circ$ $(3)$: \textit{ISR} rettet von ihr benötigte CPU-Register\\
		$\circ$ $(4)$: Eigentliche Interrupt-Behandlung\\
		$\circ$ $(5)$: Gerettete CPU-Register wiederherstellen\\
		$\circ$ $(6)$: Befehl \textit{Return from Interrupt:}\\
		\hspace*{1em}- Auf Stack abgelegte Register (\textit{Flags}, \textit{Befehlszaehler})\\
		\hspace*{1em}\hspace*{1em}wiederherstellen\\
		$\circ$ $(7)$: Normalen Programmablauf fortsetzen\\
		$\circ$ \textit{Softwareinterrupts (Systemcalls):}\\
		\hspace*{1em}- Benutzerprogramme fordern Dienste des Betriebssystems an\\
		$\circ$ \textit{Hardwareinterrupts:}\\
		\hspace*{1em}- Hardwarekomponenten (Systemuhr, HDD) fordern Dienste\\
		\hspace*{1em}\hspace*{1em}des Betriebssystems an
	}
\end{tabular}\\

\textbf{Unterbrechung \textit{mit} präemptivem Scheduling (Multitasking Betriebssystem)}\\
\vspace*{-1em}
\begin{tabular}{lc}
	\raisebox{-.5\height}{\includegraphics[scale=0.4]{images/unterbrechung_mit_bs.png}} & \makecell[l]{
		$\circ$ \textbf{Präemptiv} (bei RTOS): Rechnerkern wird bei\\
		\hspace*{1em}Interrupt der aktuell rechnende Task entzogen\\
		\hspace*{1em}\textit{wenn} höherpriore Task auf Interrupt reagieren muss\\
		\hspace*{1em}\hspace*{1em}- Interrupt zum Kontextwechsel\\
		\hspace*{1em}\hspace*{1em}- Retten des Kontextes des unterbrochenen\\
		\hspace*{1em}\hspace*{1em}\hspace*{1em}Prozesses $j$\\
		\hspace*{1em}\hspace*{1em}- eventuelle Auftragsbearbeitung\\
		\hspace*{1em}\hspace*{1em}- \textit{Scheduler:} Auswahl nächster Rechenprozess $i$\\
		\hspace*{1em}\hspace*{1em}- Kontext von Rechenprozess $i$ laden\\
		\hspace*{1em}\hspace*{1em}- Return zu $PC_i$\\
		\hspace*{1em}Bei Interrupt (z.B. \textit{Timer} oder \textit{I/O}) wird Scheduler\\
		\hspace*{1em}gestartet und zu höher priorem Prozess gewechselt\\
		\hspace*{1em}um obere Reaktionsschranke eines \textit{RTOS} einhalten\\
		\hspace*{1em}zu können (Interrupt-Sperre im \textit{Kernel} so kurz\\
		\hspace*{1em}wie möglich, obere Schranke einhalten \textit{wichtig})\\
		$\circ$ \textbf{Nicht-präemptiv} (normales Betriebssystem):\\
		\hspace*{1em}Scheduling nur bei Systemcall oder zeitgesteuert,\\
		\hspace*{1em}\textit{nicht} bei Interrupt
	}
\end{tabular}\\
\textbf{Task Control Block}\\
$\circ$ Beinhaltet: Priorität, Maschinenzustand (Register, Stack), Task-Zustand, Zeit-Quantum, Verwaltungsdaten für Betriebsmittel\\ \hspace*{1em}(\textit{Filedeskriptor}), Speicherabbildungstabellen für virtuellen Speicher (\textit{Prozessadressraum} $\rightarrow$ \textit{realer} Speicher (Code, Data, Stack))
\hspace*{1em}\hspace*{1em}\begin{lstlisting}[basicstyle=\small]
	char*			name;			/* task name */
	uint			status;			/* status of task */
	uint			priority;		/* task's current priority */
	uint			prioNormal;		/* task's normal priority */
	FUNCPTR			entry;			/* entry point of task */
	struct sigtcb	*pSignalInfo;	/* ptr to signal info for task */
	uint 			taskTicks;		/* total number of ticks */
	uint			taskIncTicks;	/* number of ticks in slice */
	struct __sFile	*taskStdFp[3]; int taskStd[3];	/* stdin, stdout, stderr fps / fds */
	char			**ppEnviron;	/* environment var table */
	int				envTblSize;		/* number of slots in table */
	int				nEnvVarEntries;	/* num env vars used */
	EXC_INFO excInfo; REG_SET regs;		/* exception info & register set */
\end{lstlisting}

\newpage

\textbf{Task-Zustände}\\
\begin{tabular}{lc}
	\raisebox{-.5\height}{\includegraphics[scale=0.375]{images/taskzustaende.png}} & \makecell[l]{
		$\circ$ \textbf{Tasks und Threads:}\\
		\hspace*{1em}- \textit{Leichtgewichtige Prozesse} um Aufwand für \textit{Kontextwechsel} zu minimieren\\
		\hspace*{1em}- Mehrere \textit{Threads} teilen sich fast \textit{kompletten} Task-Kontext\\
		\hspace*{1em}- Lediglich \textit{Stack} (mit Program Counter) und Thread-Status unterschiedlich\\
		\hspace*{1em}- sind effizient zu erzeugen und zu schedulen\\
		\hspace*{1em}- gemeinsamer (\textit{kein} getrennter) Prozessadressraum\\
		\hspace*{1em}- gemeinsame Betriebsmittel wie Files / Devices\\
		\hspace*{1em}- gemeinsamer \textit{globaler Speicher}, oft aus Effizienzgründen verwendet\\
		\includegraphics[scale=0.425]{images/threads.png}\\
	}
\end{tabular}

$\circ$ Thread erzeugen:
\begin{lstlisting}[basicstyle=\small]
#include <stdio.h>
void parent() {
	printf("The parent process has ID %d\n", getpid());
}
void child() {
	printf("The child process has ID %d\n", getpid());
	return;
}
int main(int argc, char **argv) {
	if( fork() != 0) {
		parent();
		wait();
	} else {
		child();
	}
	printf("Exit process %d \n", getpid());
	exit( 0 );
}
\end{lstlisting}

\vspace*{-2em}
$\circ$ $int$ $pthread\_create(pthread\_t *thread, pthread\_attr\_t *attr, void *(*start\_routine)(void*), void *arg)$:\\
\hspace*{1em}- Erzeugt neuen Thread (Einstiegsfunktion $start\_routine$ mit Argument $arg$)\\
\hspace*{1em}- Thread wird nebenläufig mit aufrufenden Thread abgearbeitet\\
\hspace*{1em}\hspace*{1em}- Beenden mit $pthread\_exit$ oder beenden von $start\_routine$\\
\hspace*{1em}- Attribute: \textit{Scheduling} (Art, Parmeter), \textit{Stack} (Größe, Adresse), \textit{JOINABLE} / \textit{DETACHED}\\
\hspace*{1em}\hspace*{1em}- \textit{JOINABLE:} \textit{Thread Control Block} wird solange aufgehoben, bis \textit{JOIN} auf diesen Thread aufgerufen wird\\
\hspace*{1em}\hspace*{1em}- \textit{DETACHED:} \textit{TCB} wird direkt nach Beendigung des Threads weggeworfen\\
$\circ$ $void$ $pthread\_exit(void *retval)$:\\
\hspace*{1em}- Beendigung des Threads mit $retval$\\
\hspace*{1em}- Alternative zu Beenden der $start\_routine$\\
\hspace*{1em}- Cleanup-Handler aufrufen (Ressourcen freigeben (Speicher, Filedeskriptor))\\
$\circ$ $int$ $pthread\_join(pthread\_t thread, void **thread\_return)$:\\
\hspace*{1em}- Aufruf blockiert, bis Thread sich beendet (Ergebnis steht dann in $thread\_return$)\\
$\circ$ $int$ $pthread\_detach(pthread\_t th)$:\\
\hspace*{1em}- Wenn keiner auf Thread wartet, räumt er sich bei Beendigung komplett auf (Thread Deskriptor, Stack)

\newpage

\vspace*{-2.7em}
\subsection{Speichermanagement}
\vspace*{-1.7em}
\begin{tabular}{lc}
	\raisebox{-.5\height}{\includegraphics[scale=0.375]{images/mmu.png}} & \makecell[l]{
		$\circ$ Aufgaben einer \textit{Memory-Management-Unit} (MMU): Speicherschutz \& Adressumsetzung\\
		$\circ$ \textit{MMU} ist in Hardware implementiert und wird durch das Betriebssystem\\
		\hspace*{1em}mittels \textit{Speicherabbildungstabellen} konfiguriert\\
		$\circ$ \textbf{Speicherschutz:}\\
		\hspace*{1em}- Jeder Prozess (\textbf{nicht} Thread) hat eigenen Prozessadressraum\\
		\hspace*{1em}- Zugriff nur auf eigene \textit{Daten}-, \textit{Stack}- und \textit{Code}segmente\\
		\hspace*{1em}- Zugriff auf \textit{nicht} abgebildete Adresse führt zur Interrupt (\textit{Segmentation Fault}) durch \textit{MMU}
	}
\end{tabular}

\textbf{Speicherverwaltung \textit{ohne} MMU / \textit{Adressumsetzung}}\\
$\circ$ Alle Programme sind zur \textit{Link}-Zeit bekannt, Linker kann unterschiedliche Adressbereiche pro Programm zuordnen und\\
\hspace*{1em}\textit{Sprungadressen} (d.h. Funktionsaufrufe) auflösen, es gibt ein Executable (\textit{Image})\\
$\circ$ Wenn mehrere Programme dynamisch zur Laufzeit in den Hauptspeicher geladen werden sollen:\\
\hspace*{1em}- unterschiedliche, zur \textit{Lade}-Zeit festgelegte Programmadressen (Sprünge bei Funktionsaufrufen)\\
\hspace*{1em}- Der \textit{Loader} ersetzt Adressen zur \textit{Lade}-Zeit eines Programms (z.B. Ersetzen des Symbols einer Funktion $printf()$ durch Adresse,\\
\hspace*{1em}\hspace*{1em}unter der Funktion tatsächlich verfügbar durch Symboltabelle - erst zur \textit{Ladezeit} bekannt)\\
\hspace*{1em}- Verwendung von \textit{Position Independent Code} (PIC) da natürlich zur \textit{Compile}-Zeit absolute Sprünge nicht bekannt\\
\hspace*{1em}\hspace*{1em}\textit{PIC} bedeutet die Verwendung von \textit{Relativsprüngen} (d.h. anstatt absoluter Sprung von $0x900 \rightarrow 0x1000$ wird relativer\\
\hspace*{1em}\hspace*{1em}Sprung um $0x100$ eingetragen)

\textbf{Speicherverwaltung \textit{mit} \textit{Adressumsetzung}}\\
$\circ$ Einheitlicher, \textit{virtueller} Adressraum für Programme:
\vspace*{-1.25em}
\begin{itemize}
	\setlength\itemsep{-1.25em}
	\item beginnt bei 0, umfasst kompletten adressierbaren (Adressbusbreite) Adressbereich \textit{für jedes Programm}
	\item Linker legt virtuelle Adressen in \textit{Executable} fest, Adressen werden nicht verändert, nur durch \textit{MMU} auf reale abgebildet\\
	$\rightarrow$ schnelles Laden da keine Veränderung des Executables erforderlich (nur initiale Konfiguration der MMU)
	\item Verwendung von \textit{Shared Libraries:} Mehrere \textit{Tasks} teilen sich (Code-) Segment\\
	$\rightarrow$ beliebige, virtuelle Adresse durch Linker vergeben, Abbildung auf bereits geladene Shared Library durch MMU\\
	$\Rightarrow$ Reduziert Hauptspeicherbedarf
	\item Physikalischer Adressraum meist \textit{kleiner} als virtueller Adressraum
	\item Abbildung durch \textit{Swappen} (=Auslagern des zugeordneten, physikalischen Speichers eines \textit{gesamten} Prozesses auf HDD)
	\item Abbildung durch \textit{Paging} (=Auslagern selten genutzter Speicherseiten (4kByte-\textit{Pages}) auf HDD)
	\item Swappen und Paging führen zu \textbf{Nichtdeterminismus}, für \textit{Echtzeitbetriebssysteme} also ungeeignet\\
	\text{$\rightarrow$ Es ist nicht deterministisch, wann \& wie lange eine Page geswapped wird, auch nicht, wie lange das Laden aus HDD in RAM dauert}
\end{itemize}

\textbf{Adressabbildung}\\
$\circ$ Virtuelle Adresse (z.b. \textit{32}-Bit lang) besteht aus zwei Teilen: \textit{Seitendeskriptoradresse} [31:12] und \textit{Seitenoffset} [11:0]\\
\hspace*{1em}- Seitenoffset (Adresse innerhalb einer 4kByte \textit{Page}) ist äquivalent zur physikalischen Adresse\\
\hspace*{1em}- Über den \textit{Seitendeskriptor} wird die Adressierung der \textit{Page} vorgenommen\\
\hspace*{1em}- \textit{Seitendeskriptor} enthält \textit{Zugriffsrechte} [15:12] und tatsächliche \textit{Page}-Nummer [11:0], Zugriffsrechte-Flags:\\
\hspace*{1em}\hspace*{1em}- \textbf{Schreibflag:} $1 :=$ Page darf geschrieben werden, $0 :=$ Schreibzugriff führt zu \textit{Bus-Error}\\
\hspace*{1em}\hspace*{1em}- \textbf{Datenflag:} $1: =$ Page darf gelesen werden, $0 :=$ Lesezugriff führt zu \textit{Bus-Error}\\
\hspace*{1em}\hspace*{1em}- \textbf{Codezugriff:} $1 :=$ Prozessor darf \textit{Pageinhalt} als Befehl ausführen, $0 :=$ Versuch, Inhalt als Code auszuführen führt zu \textit{Bus-Error}\\
\text{\hspace*{1em}\hspace*{1em}- \textbf{Validflag:} $1 :=$ Seite ist im Hauptspeicher, $0 :=$ Seite ausgelagert $\rightarrow$ \textit{Seite-Fehlt-Hardware-Interrupt} $\rightarrow$ \textit{Kernel} lädt Seite von HDD}

\newpage

\vspace*{-2.7em}
\subsection{I/O}
\vspace*{-1.7em}
$\circ$ Aufgaben:
\vspace*{-1.25em}
\begin{itemize}
	\setlength\itemsep{-1.25em}
	\item Aus \textbf{Applikationssicht:} Schnittstelle für einheitlichen Zugriff auf unterschiedlichste Hardware-Ressourcen
	\item Aus \textbf{Hardwaresicht:} Umgebung, um Hardware einfach \& systemkonform in Kernel zu integrieren
	\item \textbf{Zusätzlich:} Realisiert Organisationsstrukturen auf Hintergrundspeicher (\textit{Filesystem})
\end{itemize}

\vspace*{-1.25em}
$\circ$ Schnittstellenfunktion:
\vspace*{-1.25em}
\begin{itemize}
	\setlength\itemsep{-1.25em}
	\item \textit{Peripherie}-Zugriffe abgebildet durch:\\
	- Lesen und Schreiben (\textit{read} und \textit{write}): $read(fd, buf, count);$ bzw. $write(fd, \&value, sizeof(value));$\\
	- Konfigurieren und Einstellen der Betriebsart per $ioctl(fd, request, ...)$\\
	- Öffnen und Schließen (\textit{open} und \textit{close})\\
	\hspace*{1em}- \textit{Open}-Funktion des Gerätetreibers wird aufgrund der \textit{System}-Call Parameter ausgewählt (z.B. \textit{serielle},  \textit{parallele},\\
	\hspace*{1em}\hspace*{1em}oder \textit{analoge} Schnittstelle): Gerät als Pfad mit Dateinamen, Zugriffsart per Flag angeben; gibt \textit{Descriptor} als Referenz zurück\\
	\hspace*{1em}\hspace*{1em}$fd = open('Tuer', O\_RDWR);$\\
	\hspace*{1em}- \textit{Close}-Funktion gibt \textit{Ressource} wieder frei: $close(fd);$
	\item Anforderung einer \textit{Ressource} beim Betriebssystem ggf. Ablehnen aufgrund:\\
	- fehlender Zugriffsrechte\\
	- Ressource bereits belegt
\end{itemize}

\vspace*{-1.25em}
\textbf{Realisierung von \textit{Treibern}}:\\
$\circ$ \textit{Device} wird mit Namen sowie primären- und sekundären \textit{Identifier} angelegt: $mknod /dev/carrera$ $240$ $0$\\
\hspace*{1em}- Führt dazu, dass primären Identifier eine Funktion $init\_module()\{...\}$ zum Initialisieren einer $struct$ $carrera\_table$ zugeordnet wird.\\
\hspace*{1em}\hspace*{1em}Diese Struktur enthält \textit{Funktionspointer} zu \textit{Treiberfunktionen} wie $carrera\_open()\{...\}$, $carrera\_close\{...\}$, $carrera\_write()\{...\}$\\
$\circ$ Codezeile $open('/dev/carrera', O\_RDWR);$ führt dazu, dass die bei $/dev/carrera$ bzw. in $carrera\_table$ hinterlegte Funktion\\
\hspace*{1em}aufgerufen wird: $carrera\_open()\{...\}$\\
\text{$\circ$ Entfernen eines \textit{Device}s per $rmmod$ $carrera$: es wird Funktion $cleanup\_module()\{...\}$ aufgerufen, die Zeichenkette $/dev/carrera$ wieder freigibt}

\vspace*{-1.25em}
\textbf{Warum Gerät nicht aus Applikation heraus ansteuern?}
\vspace*{-1.25em}
\begin{itemize}
	\setlength\itemsep{-1.25em}
	\item Einheitliche Ressourcenverwaltung von Interrupts \& I/O-Bereiche
	\item Kapseln systemkritischer Teile\\
	- Hardwarezugriffe aus Applikation erfordern Abbildung der HW-Adressen in Prozessadressraum\\
	- Hardwarezugriffe sind \textit{sicherheitskritisch} $\rightarrow$ nur innerhalb eines Treibers durchführen\\
	- Programmierfehler könnten zum Absturz des gesamten Systems führen
	\item Überführen des Geräts in sicheren Zustand bei Applikationsfehlern\\
	- Treiber sind nach Applikationsfehler im BS noch vorhanden\\
	- Gerät wird bei Beendigung einer Applikation automatisch durch Treiber freigegeben\\
	- Bei \textit{sicherheitskritischen} Systemen wesentlich!
\end{itemize}

\vspace*{-1.25em}
\textbf{Gerätezugriff im Betriebssystem-Kern}\\
\vspace*{-1.25em}
\begin{tabular}{lc}
	\raisebox{-.5\height}{\includegraphics[scale=0.475]{images/geraetezugriff.png}} & \makecell[l]{
		$\circ$ Geräte-Schnittstelle wird von Applikation benutzt während\\
		\hspace*{1em}Treiber Funktionen realisieren, die von \textit{Kernel} selbst\\
		\hspace*{1em}aufgerufen werden (z.B. \textit{ISR}s oder Funktionen in\\
		\hspace*{1em}\textit{Kernel}- oder \textit{Timer}-Queues)\\
		$\circ$ \textbf{Ziele:} - Verkürzung der \textit{ISR}-Zeit, da währenddessen weitere\\
		\hspace*{1em}\hspace*{1em}Interrupts gesperrt\\
		\hspace*{1em}- Verkürzen der Zeit im \textit{System-Call} (z.B. durch\\
		\hspace*{1em}\hspace*{1em}\textit{Kernel-Thread}, der nur im \textit{Kernel} abgearbeitet\\
		\hspace*{1em}\hspace*{1em}wird und solange läuft, bis er sich schlafen legt\\
		\hspace*{1em}\hspace*{1em}oder seine Funktion mit $return$ verlässt - höchste Prio)\\
		\hspace*{1em}- Periodische Vorgänge in Treibern ermöglichen ( \textit{Polling})\\
		$\circ$ \textbf{Top Half:} wird gleich im Interrupt ausgeführt (befüllen der \\
		\hspace*{1em}\textit{Kernel-Queue})\\
		$\circ$ \textbf{Bottom Half:} wird in \textit{Kernel-Queue zurückgestellt}\\
		\hspace*{1em}- Kernel-Queue wird abgearbeitet, bevor $return$ in \textit{User Space}\\
		$\circ$ \textbf{Kernel-Queue:} Liste an (Treiber-)Funktionen, die der Kernel\\
		\hspace*{1em}in bestimmten Zuständen abarbeitet, z.B. $open(...)$ \\
		\hspace*{1em}oder $init\_module(...)$\\
		$\circ$ Linux-Kernel wird aufgerufen:\\
		\hspace*{1em}- Nach Abarbeitung aller Interrupts (auch \textit{Bottom Half},\\
		\hspace*{1em}\hspace*{1em}hochpriore User-Threads auch Vorrang)\\
		\hspace*{1em}- Vor Scheduling \& bei jedem Tick der Systemuhr
	}
\end{tabular}

\newpage

\textbf{Gerätezugriff im Betriebssystem-Kern}\\
$\circ$ \textit{Timer-Queue:} Liste aus Paaren $(Treiberfunktion$, $Zeitpunkt)$: Zum Zeitpunkt wird Treiberfunktion abgearbeitet\\
$\circ$ \textit{Big Kernel Lock:} Während etwas im Kernel ausgeführt wird, sind alle \textit{ISR}s gesperrt, gibt es heute nicht mehr

\vspace*{-1.25em}
\textbf{Latenzzeit}\\
\begin{tabular}{lc}
	\raisebox{-.5\height}{\includegraphics[scale=0.325]{images/latenz.png}} & \makecell[l]{
		$\circ$ \textbf{Reaktionszeit:} $t_R = t_V + t_W$ (Verarbeitungs- + Wartezeit)\\
		$\circ$ \textbf{Hardware-Latency:} Zeit bis Hardware-Ereignis als Interrupt über Bus der CPU\\
		\hspace*{1em}gemeldet wird (wenige \textit{Gatterlaufzeiten}, im $ns$-Bereich)\\
		$\circ$ \textbf{Preemption-Delay:} \textit{OS} im kritischen, nicht unterbrechbaren\\
		\hspace*{1em}Abschnitt (Interrupts gesperrt, bei Standard-OS ca. $10ms$)\\
		$\circ$ \textbf{ISR:} Verarbeitungszeit der \textit{Interrupt-Service-Routine} (\textit{Systemanteil}),\\
		\hspace*{1em}bei \textit{QNX} mit 200MHz Pentium: $1.4\mu s$\\
		$\circ$ \textbf{System Call:} Verzögerung wenn Interrupt während eines \textit{System-Call}s auftritt,\\
		\hspace*{1em}System-Call fertig stellen oder abbrechen (bei Standard-OS viele $ms$)\\
		$\circ$ \textbf{Scheduling:} Bei \textit{QNX} mit 200MHz Pentium: $2.9\mu s$\\
		$\circ$ \textbf{Context-Switch:} Aufwand, um anderen Task weiterzubearbeiten (sehr variable)\\
		$\circ$ Schließlich Weiterbearbeitung höher priorer Tasks
	}
\end{tabular}

\vspace*{-1.25em}
\textbf{Filesysteme}\\
$\circ$ Bei \textit{Embedded Systems} kaum Festplatten, viel eher:\\
\hspace*{1em}- \textit{RAM}-Filesysteme (beim Starten aus persistentem Speicher geladen, beim Beenden zurückgeschrieben)\\
\hspace*{1em}- \textit{EEPROM}, \textit{Flash} oder \textit{Solid State Drive}s\\
$\circ$ Organisation mit Filesystemen wie \textit{FAT}, \textit{NTFS}, \textit{Ext3}\\
\hspace*{1em}- schneller Zugriff \& wenig Overhead für Verwaltungsinformationen\\
$\circ$ Verwendung von \textit{Caches}:\\
\hspace*{1em}- Daten temporär inkonsistent, kein zeitlicher Determinismus bei Zugriff (man weiß nicht, wann und ob welcher\\
\hspace*{1em}\hspace*{1em}Speicherbereich im Cache liegt)\\
\hspace*{1em}- \textit{Sync-Mode} $\rightarrow$ keine Verwendung von Caches sondern explizit synchronisieren

\vspace*{-1.25em}
\textbf{Synchronisation}\\
$\circ$ \textbf{Zugriffszeit}: Zeit zwischen Auftrag und Erfüllung des Auftrags, Mechanismen zur Synchronisation von Prozessen mit Gerätezugriff\\
$\circ$ \textbf{Synchroner Zugriff}: implizites Warten, auf Gerät wartender \textit{Task} wird schlafen gelegt bis:\\
\hspace*{1em}- Gerät antwortet, Fehlersituation (z.B. \textit{Timeout}) eintritt oder \textit{Task} ein \textit{Signal} erhält\\
$\circ$ \textbf{Asynchroner Zugriff}: explizites Warten, Zugriff auf Gerät kehrt sofort zurück:\\
\text{\hspace*{1em}- Task kann weiterarbeiten; Mitteilung durch OS an Task via Polling / Ereignis (\textit{Signal}) / \textit{Callback}-Funktion: Task holt Ergebnis ab}\\
\hspace*{1em}- \textbf{Probleme:}\\
\hspace*{1em}\hspace*{1em}- Mehrere Aufträge können gleichzeitig vorliegen, Dienste müssen sich daher auf selben Auftrag beziehen können\\
\hspace*{1em}\hspace*{1em}- ggf. wird \textit{Dienstkette} $\{$ Auftragstatus ermitteln $\}$ $\rightarrow$ $\{$ Ergebnis holen $\}$ nicht bis zum Ende einer Applikation beendet\\
\hspace*{1em}\hspace*{1em}- Zustandsverwaltung im OS erforderlich\\
\hspace*{1em}- async. Zugriff mit \textbf{nicht}-blockierenden Diensten:\\
\hspace*{1em}\hspace*{1em}- Leseauftrag $\rightarrow$ Warten auf Ergebnis $\rightarrow$ Ergebnis holen (Polling, Signal / Schlafen, Signal / Callback)\\
\hspace*{1em}\hspace*{1em}- Höhere Performance (Audio, Video, Netzwerk, Datenbanken) + besseres Antwortverhalten\\
\hspace*{1em}\hspace*{1em}- Umgesetzt über Funktionen wie $aio\_read$, $aio\_write$, $aio\_fsync$ (z.B. Sync. zwischen Cache und Festplatte)\\
\hspace*{1em}- async. Zugriff \textbf{mit} Thread und \textbf{blockierendem} Aufruf:\\
\hspace*{1em}\hspace*{1em}- Thread erzeugen $\rightarrow$ im Thread blockierend auf Ressource zugreifen $\rightarrow$ Thread-Ende abwarten\\
\text{\hspace*{1em}\hspace*{1em}- Beim gleichzeitigen Warten auf mehrere Kanäle verwenden, Flag $O\_NONBLOCK$ um Gerät via $open(...)$ nicht-blockierend zu öffnen}\\
$\circ$ \textbf{Nicht blockierender Aufruf} (ähnlich zu blockierendem Lesezugriff):\\
\hspace*{1em}- Liefert Ergebnis sofort wenn vorhanden, liefert andernfalls $\{$ Nichts zum Lesen vorhanden $\}$

\subsection{Zeitdienste}
\vspace*{-1.7em}
\text{$\circ$ \textbf{Aufgaben:} zyklische Interruptgenerierung, Zeitmessung, Watchdog (\textit{Zeitüberwachung}), Zeitsteuerung für Dienste}\\
\hspace*{1em}- Realisierung über \textit{Realzeituhren} / \textit{Timer}, sind \textbf{nicht} kontinuierlich sondern \textbf{diskret}\\

\vspace*{-1.7em}
\textbf{Zyklische Interruptgenerierung}\\
$\circ$ \textbf{Systemzeit} (Ticks):\\
\hspace*{1em}- Timer generiert zyklisch (z.B. alle $1 ms$) Interrupt, zugehörige \textit{ISR}:\\
\hspace*{1em}\hspace*{1em}- ruft Scheduler auf, bearbeitet zeitabhängige Systemdienste (\textit{Weckrufe}), dient als \textit{Softwaretimer}\\
\hspace*{1em}- Genauigkeit hängt von Zeitbasis ab\\
$\circ$ Zyklische Bedienung von Interface-Karten (Taktgenerierung durch Bus-Controller)

\newpage

\textbf{Zeitmessung}\\
$\circ$ Zuordnung hochgenauer Zeitstempel zu Ereignissen\\
$\circ$ Berechnung von Geschwindigkeiten über Differenzzeitmessung (z.B. Fahrzeuge mit Lichtschranken)

\vspace*{-1.25em}
\textbf{Watchdog} (Zeitüberwachung):\\
$\circ$ Zur Überwachung der Einhaltung von Echtzeitbedingungen\\
$\circ$ Zur Zeitüberwachung einfacher Dienste (Datenausgabe, Peripherie)\\
$\circ$ Zur Zeitüberwachung von Systemkomponenten, User-Interaktionen (\textit{Totmann} in Lokomotiven) oder des gesamten Systems\\
$\circ$ Mechanismus:\\
\hspace*{1em}- System muss in regelmäßigen Abständen einen rückwärts laufenden Timer zurücksetzen (d.h. Startwert neu setzen)\\
\hspace*{1em}- Wenn System in undefiniertem Zustand und unfähig, Zähler zurückzusetzen, läuft dieser auf Null $\rightarrow$ löst \textit{Interrupt} aus:\\
\hspace*{1em}\hspace*{1em}- Alarm / Fehlermeldung\\
\hspace*{1em}\hspace*{1em}- Systemreset (entweder zuerst noch \textit{ISR} aufrufen und dann CPU-Reset oder direkt CPU-Reset)\\
\hspace*{1em}\hspace*{1em}- \textbf{Problem:} Es gibt Momente, in denen \textit{ISR}s nicht ausgeführt werden (Interrupt Sperre), daher lieber direkt Reset!\\
$\circ$ \textbf{Erstellen:} $WDOG\_ID$ $wdCreate$ $(void)$, \textbf{Löschen:} $wdDelete$ $(WDOG\_ID)$, \textbf{Starten:} $wdStart$ $(WDOG\_ID$, $delay$, $FUNCPTR$, $param)$,\\
\hspace*{1em}\textbf{Abbrechen:} $wdCancel(WDOG\_ID)$

\vspace*{-1.25em}
\textbf{Zeitsteuerung für Dienste}:\\
$\circ$ Ausführen spezifischer Aufgaben in regelmäßigen Abständen (Backups, Messwerte erfassen)

\vspace*{-1.25em}
\textbf{Zeitgeber}:\\
$\circ$ \textit{Absolut}-Zeitgeber: Uhren (\textit{clocks}), \textit{Relativ}-Zeitgeber: Timer (\textit{timer})\\
$\circ$ Realisierung in Hardware oder per Software via \textbf{Vorwärtszähler} / \textbf{Rückwärtszähler}\\
\hspace*{1em}- \textbf{repetitive} Zähler: Zählwert wird nach Ablauf (Zählerstand = 0) selbstständig neu geladen\\
\hspace*{1em}- \textbf{single shot} Zähler: expliziter Neustart erforderlich

\vspace*{-1.25em}
\textbf{Zugriff auf Zeitdienste - Hardwarelevel}:\\
$\circ$ \textit{Zeit-bezogene} Hardware: Echtzeituhren (Absolutzeitgeber), Frequenzteiler, Vor- und Rückwärtszähler, Watchdog\\
$\circ$ \textbf{Absolutzeitgeber:} Stellen Absolutzeit ($HH:mm:ss:ms$ $TT.MM.YYYY$) bereit, \textit{batteriegepuffert},\\
\hspace*{1em}möglichst genau bei \textit{verteilten} Echtzeitsystemen

\vspace*{-1.25em}
\textbf{Zugriff auf Zeitdienste - Kernellevel}:\\
$\circ$ Zyklische Timerinterrupts im Betriebssystemkern:\\
\hspace*{1em}- Treiber können Tasks für variable Dauer in $\{$ wartend $\}$ versetzen\\
\hspace*{1em}- Module können zyklischen oder einmaligen (zu einem Relativzeitpunkt) Funktionsaufruf zulassen\\
$\circ$ \textbf{Vorsicht} bei Realzeit im Kernel (Sekunden statt Ticks): Abstand zwischen zwei Ticks kann von System zu System variieren\\
$\circ$ \textbf{Zählerüberlauf:} Muss in allen Schichten geprüft werden - um darauf basierende Fehler möglichst früh zu erkennen:\\
\hspace*{1em}$\rightarrow$ relative Zeit wird auf kurz vor Überlauf des Timers gesetzt!

\vspace*{-1.25em}
\textbf{Zugriff auf Zeitdienste - Userlevel}:\\
\text{$\circ$ Absolutzeitanfragen z.B. mit $gettimeofday()$, um Prozess / Thread für definierte Zeit in Zustand $\{$ wartend $\}$ versetzen: $sleep(seconds)$}

\vspace*{-1.25em}
\textbf{Kritische Punkte}: in \textit{Kernelebene:} Relativzeit führt zu Zählerüberlauf; in \textit{User-Ebene:} Sommer-/Winterzeit, Schalttage, Zeitzone

\vspace*{-1.25em}
\textbf{Zeitdrift}:\\
\text{$\circ$ Durch ungenaue Uhren, ungenaue Start-Systemzeit $\rightarrow$ \textit{Zeitsynchronisation} mit Broadcastmessages eines \textit{Zeitservers} (\textit{Mikrosekundenbereich})}\\
\hspace*{1em}- Synchronisation mit \textit{Network Time Protocol} (NTP) / DCF77 / statistische Berechnungen

\vspace*{-1.25em}
\textbf{Zeitkorrektur}:\\
$\circ$ \textbf{Problem:} Sprunghafte Korrektur von Absolutzeiten\\
\hspace*{1em}- Zurückstellen: Zeitpunkte kommen doppelt vor\\
\hspace*{1em}- Vorstellen: Zeitpunkte werden übersprungen\\
\text{$\Rightarrow$ Abbremsen/Beschleunigen der Systemuhr: $adjtimex(struct$ $timex)$, keine doppelten/fehlenden Zeitpunkte, Zeit vergeht langsamer/schneller}\\
$\circ$ Durch Downtime (Serverupdate) entfallen geplante Aktionen $\rightarrow$ durchgeführte Aktionen protokollieren und bei Neustart nachholen

\vspace*{-1.25em}
\textbf{Repräsentation von Zeit}:\\
$\circ$ Absolutzeit: $struct$ $time\_t$ (Jahr, Wochentag, Monat, Tag, Stunde, Minute, Sekunde)\\
$\circ$ Absoluttimer: $struct$ $timespec$ $\{tv\_sec$, $tv\_nsec\}$\\
$\circ$ Relativzeiten und Zeitpunkte für Timer: $struct$ $itimerspec$ $\{it\_interval$, $it\_value\}$\\
\hspace*{1em}- $it\_interval$ $\neq 0$: Timer startet Intervallweise, $it\_value$ $\neq 0$: Timer startet einmal in Absolutzeit $it\_value$\\
\hspace*{1em}- $it\_interval$ $\neq 0$ \textbf{und} $it\_value$ $\neq 0$: Timer startet im Zeitpunkt $it\_value$ Intervallweise mit $it\_interval$

\vspace*{-1.25em}
\textbf{API für Zeitdienste}:\\
$\circ$ Prozess für $n$ $ns$ schlafen legen: $nanosleep(timespec$ $request$, $timespec$ $remainder\_after\_signal)$\\
\text{$\circ$ Uhrzeit abfragen/setzen/Auflösung: $clock\_gettime(clockid\_t$, $timespec)$\textbf{/}$clock\_settime(clockid\_t$, $const$ $timespec)$\textbf{/}$clock\_getres(clockid\_t$, $timespec)$}\\
\text{$\circ$ Timer erzeugen/löschen/Ablauf: $timer\_create(clockid\_t$, $sigevent$, $timer\_t)$\textbf{/}$timer\_delete(timer\_t)$\textbf{/}$timer\_settime(timer\_t$, $itimerspec$ $val$, $itimerspec$ $remain)$}

\newpage

\vspace*{-2.5em}
\section{Programmiertechniken bei Echtzeitbetriebssystemen}
\subsection{Verschiedene Programmiersprachen}
\vspace*{-1.75em}
$\circ$ \textbf{Assembler:} selten, bei zeitkritischen Anwendungen; \textbf{C:} \textit{Die} Programmiersprache für \textit{Embedded Systems}\\
\hspace*{1em}\textbf{C++:} Seltener als C, tiefes Wissen für Effizient erforderlich; \textbf{ADA:} Schöne, typsichere Sprache, schwer \textit{hardwarenah} programmierbar\\
\hspace*{1em}\textbf{Java:} weit verbreitet, hohe Produktivität, \textit{aber:} nicht deterministisch durch Garbage-Collection / Memory-Management $\rightarrow$ \textit{RT}-Java

\subsection{Endliche Zustandsautomaten (\textit{Finite State Machines})}
\vspace*{-1.75em}
\begin{tabular}{lc}
	\raisebox{-.5\height}{\includegraphics[scale=0.4]{images/zustandsautomat.png}} & \makecell[l]{
		$\circ$ Weit verbreitetes \textit{Paradigma} bei Ereignis-orientierten Systemen\\
		$\circ$ Bestehen aus einer Anzahl an \textbf{Zuständen}, \textbf{Ereignissen}, \textbf{Transitionen} \& \textbf{Ausgaben}\\
		$\circ$ System befindet sich zu \textit{einer} Zeit in genau \textit{einem} Zustand\\
		$\circ$ Eintretendes Ereignis führt zu Zustandsübergang in einen \textit{Folgezustand}\\
		$\circ$ Übersichtlich Implementierbar: allgemeiner Interpreter (\textit{switch-case}) oder Beschreibung (\textit{Automatentafel})\\
		$\circ$ Geeignet für \textbf{digitale} (also \textit{diskrete}) Ereignisse bzw. Zustände (\textbf{nicht} für analoge, kontinuierliche Zustände)\\
		$\circ$ Überprüfung des \textit{Abdeckungsgrades} als auch der Laufzeit (deterministisch) möglich
	}
\end{tabular}

\subsection{Richtlinien zur Entwicklung eingebetteter Systeme}
\vspace*{-1.75em}
$\circ$ Zerlegung einer Aufgabe auf mehrere (\textit{konkurrierende} und \textit{kooperierende}) Tasks zur schritthaltenden Verarbeitung (\textit{Multitasking})\\
$\circ$ Unterbrechbarkeit (\textit{Preemption}) der Tasks\\
$\rightarrow$ \textbf{Kontrollfluss:} Synchronisation zwischen Tasks mit \textit{Semaphore} \& Events\\
$\rightarrow$ \textbf{Datenaustausch:} Inter-Prozess-Kommunikation (\textit{IPC}) zwischen Tasks\\
$\rightarrow$ \textbf{Scheduling:} Priorisierung der Tasks

\subsection{Kontrollfluss am Beispiel der \textit{Pathfinder Mars-Mission}}
\vspace*{-1.75em}
\begin{tabular}{lc}
	\raisebox{-.5\height}{\includegraphics[scale=0.3275]{images/pathfinder_01.png}} & \makecell[l]{
		$\circ$ \textbf{Z-Task:} Periodische Zustandsüberwachung (Temperatur, Ströme),\\
		\hspace*{1em}hat \textbf{mittlere} Priorität\\
		$\circ$ \textbf{M-Task:} Erfassung meteorologischer Messwerte, hat \textbf{niedrigste}\\
		\hspace*{1em}Priorität\\
		$\circ$ \textbf{Bus-Management-Task:} Datenaustausch über Informations-Bus,\\
		\hspace*{1em}hat \textbf{höchste} Priorität\\
		$\circ$ \textbf{RK:} Belegung des Rechnerkerns\\
		$\circ$ \textbf{S:} Wert der \textit{Semaphore} für den Informationsbus\\
		$\circ$ \textbf{Konkurrierende Prozesse:} \textit{M}- und \textit{B}-Task \textit{konkurrieren} um\\
		\hspace*{1em}Zugriff auf Daten (sind \textbf{nicht} disjunkt)\\
		$\circ$ \textbf{Kooperierende Prozesse:} Prozess liefert Daten für anderen\\
		\hspace*{1em}(\textit{Erzeuger}-\textit{Verbraucher}-\textit{Modell}) - ebenfalls \textbf{nicht} disjunkt\\
		$\circ$ \textbf{Disjunkte Prozesse:} Ablauf eines Prozesses/Threads\\
		\hspace*{1em}unabhängig von anderen (ebenfalls disjunkten) Prozessen\\
		$\Rightarrow$ Die Wirkung der gegenseitigen Beeinflussung von \textit{nicht}\\
		\hspace*{1em}disjunkten, parallelen Prozessen ohne Synchronisation ist \textit{nicht}\\
		\hspace*{1em}vorhersagbar und im Regelfall auch \textit{nicht} reproduzierbar
	}
\end{tabular}

\subsection{Kritischer Bereich}
\vspace*{-1.75em}
\textbf{Race Condition}\\
$\circ$ Unsynchronisierter Zugriff mehrerer Threads bzw. auf Prozesse auf \textit{dieselben} Daten:
\vspace*{-1.25em}
\begin{itemize}
	\setlength\itemsep{-1.25em}
	\item Ergebnis/Konsistenz vom Prozessfortschritt abhängig (z.B. \textit{Ringpuffer}) $\rightarrow$ Race conditions \textit{unbedingt} vermeiden
	\item \text{Lösung: \textit{Gegenseitiger Ausschluss} (Mutual Exclusion) $\rightarrow$ höchstens \textit{ein} Prozess tritt in kritischen Abschnitt ein, abgesichert durch \textbf{Mutex}}
\end{itemize}

\vspace*{-1.75em}
\noindent\begin{minipage}{.45\textwidth}
	\begin{lstlisting}[caption=Prozess 1,frame=tlrb]{Name}
	i := read(counter); /* Liest 0 */
	/* Context-Switch zu Prozess 2 */
	i++;
	write(counter, i);
	/* Schreibt ebenfalls 1 zurück */
	\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.45\textwidth}
	\begin{lstlisting}[caption=Prozess 2,frame=tlrb]{Name}
	i := read(counter); /* Liest 0 */
	i++;
	write(counter, i);
	/* Schreibt 1 zurück*/
	\end{lstlisting}
\end{minipage}

\newpage

\vspace*{-2.75em}
\textbf{Binäre Semaphore vs Mutex}\\
$\circ$ Binäre Semaphore (hat Werte 0 \& 1): exklusive Verwendung zum Erzeugen von Ereignisses im Erzeuger-Verbraucher-Problem\\
$\circ$ Mutex: exklusive Verwendung als \textit{Rekursiver Mutex}:\\
\hspace*{1em}- Wenn der Prozess bereits einen Mutex inne hat, der bei einem weiteren kritischen Abschnitt (z.B. über einen Funktionsaufruf)\\
\hspace*{1em}\hspace*{1em}wieder benötigt wird, darf der Prozess eintreten, da er den Mutex ja bereits besitzt. Das erste Freigeben des Mutex\\
\text{\hspace*{1em}\hspace*{1em}(z.B. am Ende der aufgerufenen Funktion) ist nicht wirksam, er besitzt ja immer noch den Mutex für den ersten kritischen Abschnitt},\\
\hspace*{1em}\hspace*{1em}erst nach dem Verlassen diesen Abschnitts wird der Mutex freigegeben:

\vspace*{-1.75em}
\noindent\begin{minipage}{.45\textwidth}
	\begin{lstlisting}[caption=Funktion 1,frame=tlrb]{Name}
	func init() {
		lock();
		/* do something */
		unlock();
	}
	\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.45\textwidth}
	\begin{lstlisting}[caption=Funktion 2,frame=tlrb]{Name}
	func main() {
		/* Mutex initial genommen */
		lock();
		init();
		/* Mutex wieder freigeben */
		unlock();
	}
	\end{lstlisting}
\end{minipage}

\vspace*{-1.75em}
\textbf{Semaphore}\\
$\circ$ Synchronisationswerkzeug: Zur Signalisierung bei Erzeuger/Verbraucher (Erzeuger \textit{gibt} Semaphore, Verbraucher \textit{nimmt} Semaphore)\\
$\circ$ Bei gegenseitigem Ausschluss: Semaphore nehmen bei Betreten und geben bei Verlassen\\
$\circ$ \textit{Integer}-Variable, wir zu Beginn auf Maximalwert $N$ initialisiert (= Anzahl Prozesse, die kritischen Bereich betreten dürfen)\\
\text{$\circ$ \textbf{P-Operation} (Semaphore nehmen): Bei Zugriff auf Semaphore wird Wert um 1 verringert \& Prozess schlafen gelegt, falls Wert negativ}\\
\text{$\circ$ \textbf{V-Operation} (Semaphore geben): Bei Freigabe einer Semaphore wird Wert um 1 erhöht \& ein wartender Prozess geweckt, falls Wert $\leq 0$}


\subsection{Kritischer Bereich und Prioritätsinversion am Beispiel der \textit{Pathfinder Mars-Mission}}
\vspace*{-1.75em}
\begin{tabular}{lc}
	\raisebox{-.5\height}{\includegraphics[scale=0.3275]{images/pathfinder_02.png}} & \makecell[l]{
		$\circ$ Niedrig-priore $M-Task$ läuft, belegt Semaphore\\
		$\circ$ Hoch-priore $B-Task$ fängt an zu laufen, erkennt, dass Semaphore belegt\\
		\hspace*{1em}$\rightarrow$ legt sich wieder schlafen\\
		$\circ$ $Z-Task$ läuft an, verdrängt $M-Task$ aufgrund höherer Priorität, läuft bis fertig\\
		$\circ$ Anschließend läuft zuvor gelaufener $Z-Task$ wieder an, nach einiger Zeit gibt\\
		\hspace*{1em}es \textit{Watchdog}-Error da $B-Task$ zu lange nicht drann kam\\
		$\circ$ \textbf{Prioritätsinversion:}\\
		\hspace*{1em}- Tasks unterschiedlicher Priorität: \textbf{Hoch} ($B-Task$), \textbf{Mittel} ($Z-Task$),\\
		\hspace*{1em}\hspace*{1em}\textbf{Niedrig} ($M-Task$)\\
		\hspace*{1em}- \textbf{Hoch} \& \textbf{Niedrig} mit gemeinsamen, kritischen Bereich\\
		\hspace*{1em}- \textbf{Niedrig} ist im kritischen Bereich, wenn \textbf{Hoch} ebenfalls betreten will\\
		\hspace*{1em}- \textbf{Hoch} wartet, bis \textbf{Niedrig} Bereich wieder verlässt\\
		\hspace*{1em}- \textbf{Mittel} verdrängt \textbf{Niedrig} $\rightarrow$ \textbf{Hoch} muss auf\\
		\hspace*{1em}\hspace*{1em}Beenden von \textbf{Mittel} warten\\
		\hspace*{1em}$\Rightarrow$ \textbf{Mittel} ist somit höherprior als \textbf{Hoch}
	}
\end{tabular}

\textbf{Lösung der Prioritätsinversion durch Prioritätsvererbung (\textit{Priority Inheritance Protocol})}\\
$\circ$ Sobald \textbf{Hoch} kritischen Bereich betreten will, ist es wichtig, dass dieser wieder freigegeben wird, \textbf{Niedrig} aber \textit{zu unwichtig}\\
$\circ$ Lösung: Priorität von \textbf{Hoch} auf \textbf{Niedrig} für die Zeit der Abarbeitung des kritischen Bereiches übertragen\\
$\circ$ \textbf{Allgemein:} Falls Job \textbf{Hoch} Semaphore anfordert, welche gegenwärtig von Job \textbf{Niedrig} gehalten wird, dann wird Priorität von \textbf{Niedrig}\\
\hspace*{1em}auf die Priorität von \textbf{Hoch} angehoben, sobald der Job \textbf{Niedrig} Semaphore wieder freigibt, bekommt er initiale Priorität zurück

\vspace*{-1.25em}
\textbf{Lösung der Prioritätsinversion durch \textit{Priority Ceiling Protocol}}\\
\text{$\circ$ Anheben der Priorität des Tasks \textbf{Niedrig} auf Priorität des höchstprioren Tasks, mit dem er sich Ressourcen teilt (kann Deadlocks verhindern)}\\
$\circ$ Schwer zu implementieren da kritische Bereiche und Tasks, die diese verwenden, dem Scheduler bekannt sein müssen

\vspace*{-1.25em}
\textbf{Deadlock}\\
$\circ$ \textit{Critical Sections} können zu Verklemmungen (\textit{Deadlocks}) führen (\textbf{Task A} ruft $P(S_1)$ auf, \textbf{Task B} ruft $P(S_2)$ auf,\\
\hspace*{1em}\textbf{Task A} wartet nun auf $S_2$, \textbf{Task B} auf $S_1$

\vspace*{-1.25em}
\textbf{Schreib-/Lese Locks}\\
$\circ$ Race-Condition nur dann kritisch, wenn Rechenprozesse Daten \textit{modifizieren}, reines \textit{Lesen} unkritisch $\rightarrow$ \textit{Spezielle Semaphore} erlauben\\
\hspace*{1em}\text{parallelen Lesezugriff, Schreibzugriff \textbf{nur} exklusiv: Rechenprozess teilt bei Anforderung des Mutexes mit, ob er Lesen oder Schreiben will}\\

\newpage

\hspace*{1em}\textbf{1.} Kritischer Abschnitt frei $\rightarrow$ Zugriff gewährt\\
\hspace*{1em}\textbf{2.} Lesender Prozess belegt Critical Section $\rightarrow$ Schreibender Prozess wird blockiert, lesender zugelassen\\
\hspace*{1em}\textbf{3.} Schreibender Prozess belegt Critical Section $\rightarrow$ Prozess wird abgewiesen, egal ob lesend oder schreibend

\vspace*{-1.25em}
\textbf{Weitere Schutzmaßnahmen}\\
$\circ$ Semaphore \textbf{nur} zum Schutz kritischer Abschnitte für Prozesse im \textbf{User-Bereich}\\
$\circ$ Kernel-Ebene: \textbf{Unterbrechungsschutz} (Interrupts für die Zeit des Zugriffs auf kritischen Abschnitt sperren, Latenzzeiten kurz halten)\\
$\circ$ Kernel-Ebene bei \textit{Multiprozessorsystemen} (mehrere \textit{ISR}s können \textit{echt parallel} bearbeitet werden, \textit{Unterbrechungsschutz} hilft nicht):\\
\text{\hspace*{1em}\textbf{Spinlock}: Gemeinsame Variable entscheidet, ob Critical Section betreten werden darf (\textit{Busy waiting} - Polling eines Flags, falls besetzt)}\\
\hspace*{1em}\hspace*{1em}- Spinlock kehrt im Einprozessorsystem nicht zurück - \textbf{nicht verwenden}

\vspace*{-1.5em}
\begin{center}
	\begin{tabular}{c|c|c|c}
		\textbf{Methode} & \textit{User Level} & \textit{Einprozessorsystem}: Kernel Level & \textit{SMP}: Kernel Level\\
		\hline
		Unterbrechungssperre & Nein & Ja & Nein\\
		Spinlock & Nein & Nein & Ja\\
		Semaphore & Ja & Ja & Ja
	\end{tabular}
\end{center}

\subsection{Events}
\vspace*{-1.75em}
$\circ$ Task wartet auf ein Event (Ereignis), andere Task setzt/signalisiert Event (mit \textit{Semaphore} oder \textit{Message-Queue} realisiert)

\subsection{Condition Variable}
\vspace*{-1.75em}
$\circ$ Ist ein \textit{Event}, das an die Änderung einer Bedingung (z.B. Überschreiten eines Puffer-Füllständes) geknüpft ist, \textbf{3 Dinge} zusammen:\\
\hspace*{1em}- \textbf{Condition Variable} := Event, wenn Bedingung sich ändert\\
\hspace*{1em}- \textbf{Global (shared) Variable} := Variable, über die Bedingung formuliert ist\\
\hspace*{1em}- \textbf{Mutex} := sichert Bereich $\{$ Überprüfen der Bedingung/Warten auf Veränderungssignal $\}$ ab

\vspace*{-1em}
\begin{center}
	\begin{lstlisting}[basicstyle=\small]
		pthread_mutex_t spar_lock;
		pthread_cond_t spar_aenderung;
		unsigned int erspartes;
		
		void ausgeben(int menge) {
			pthread_mutex_lock(&spar_lock);
			while(erspartes < menge) {
				/* gibt 'spar_lock' frei, damit einzahlen überhaupt
				 * möglich ist, ansonsten gäbe es 'Deadlock'
				 */
				pthread_cond_wait(&spar_aenderung, &spar_lock);
			}
			erspartes -= menge;
			pthread_mutex_unlock(&spar_lock);
		}
		
		void einzahlen(int menge) {
			pthread_mutex_lock(&spar_lock);
			erspartes += menge;
			pthread_cond_broadcast(&spar_aenderung);
			pthread_mutex_unlock(&spar_lock);
		}
	\end{lstlisting}
\end{center}

\vspace*{-1.75em}
\subsection{Signale}
\vspace*{-1.75em}
$\circ$ \textit{Signal} führt zu Unterbrechung des Programmablaufs innerhalb einer Applikation:\\
\hspace*{1em}- Programm wird abgebrochen ($exit()$)\\
\hspace*{1em}- Programm reagiert mit implementierten $Signal-Handler()$ (ähnlich zu einer \textit{Interrupt-Service-Routine})\\
$\circ$ \textit{Signal} kann ausgelöst werden durch:\\
\hspace*{1em}- Programm\\
\hspace*{1em}- Ereignisse innerhalb des Betriebssystems selbst: Zugriff auf nicht vorhandenen Speicherbereich ($\rightarrow$ \textit{Segmentation-Fault-Signal}\\
\hspace*{1em}- ggf. Abfangen um noch wichtige Daten zu sichern

\vspace*{-1.75em}
\begin{center}
	\begin{tabular}{c|c}
		\textbf{Signale} & \textbf{Events}\\
		\hline
		\makecell[c]{Kommen \textit{asynchron} zum Programmablauf\\werden \textit{asynchron} verarbeitet} & \makecell[c]{Kommen \textit{synchron} zum Programmablauf\\werden \textit{synchron} verarbeitet}\\
		Ähnlich zu \textit{Interrupt-Service-Routine} & \textit{Rendezvous}-Charakter
	\end{tabular}
\end{center}

\newpage

$\circ$ \textbf{Signale} führen außerdem zum sofortigen Abbrechen eines gerade aktiven, blockierenden \textit{System-Calls}\\
$\rightarrow$ Jeden Systemcall überprüfen, ob durch Signal unterbrochen ($errno$ $=$ $EINTR$) \& \textit{neu} aufsetzen falls ja\\
$\circ$ $sigaction(signum$, $struct$ $sigaction$ $*act$, $sigaction)$: $*act$ enthält Adresse des \textit{Signal-Handlers}, der bei Signal von OS aufgerufen wird\\
$\circ$ $kill(pid\_t$, $sig)$: einem \textit{Task} oder einer \textit{Task-Gruppe} wird ein Signal geschickt

\subsection{Message Queues}
\vspace*{-1.75em}
$\circ$ Zum Transport von Daten zwischen Tasks (\textit{Inter-Prozess-Kommunikation})\\
$\circ$ Daten mit unterschiedlicher, nach oben begrenzter Größe von Task $A$ nach Task $B$ senden\\
$\circ$ Über Filesystem mit $Namen$, \textit{task-intern} per \textit{Message Queue ID} identifiziert\\
$\circ$ Blockierendes Senden (Queue voll) \& Empfangen (Queue leer)

\subsection{Shared Memory}
\vspace*{-1.75em}
$\circ$ Gemeinsamer Speicherbereich (= globale Variable(n)), Realisierung \textit{trivial} - aber \textit{Critical Section} nicht vergessen\\
$\circ$ Realisierung z.B. über OS-Filesystem, da Speicheradresse von Task zu Task unterschiedlich sein kann, sollte sie innerhalb von\\
\hspace*{1em}Datenstrukturen relativ zu Beginn des Speicherbereichs angegeben werden

\subsection{Sockets}
\vspace*{-1.75em}
$\circ$ Kommunikation über Rechnergrenzen hinweg (aber auch \textit{lokal}) möglich\\
$\circ$ Verbindung identifiziert über $Rechnername[IP]$ + $Port$-$Nummer$: \textit{Server} öffnet Port (bei TCP zusätzlich Handshake),\\
\hspace*{1em}\textit{Client} öffnet Verbindung \& sendet an Server

\subsection{Busy-Loops}
\vspace*{-1.75em}
$\circ$ Echtzeitsteuerung ist nur mit der Regelung \textbf{eines einzigen} technischen Prozesses beschäftigt ($volatile$ bei Pollen nicht vergessen)\\
$\circ$ Rechnerprozess pollt ständig technischen Prozess nach Anforderungen; ist einfach programmierbar, kein OS nötig, sehr häufig vertreten
\vspace*{-1.75em}
\begin{center}
	\begin{lstlisting}
	while(True) {
		Lese Wert ein
		Bearbeite Aufgabe
		Warte (100ms)
	}
	\end{lstlisting}
\end{center}
\vspace*{-1.5em}

\subsection{Time-Triggered}
\vspace*{-1.75em}
$\circ$ Applikation prüft zyklisch, ob bestimmte Bedingung erfüllt ist (Zeitbasis aus dem Betriebssystem, Peripherie ist \textbf{rein passiv}\\
\text{$\circ$ Abtastzeit so kurz wählen, dass: kein Zustand verloren geht (\textit{Abtasttheorem}) / Reaktion rechtzeitig erfolgen kann (\textbf{2. Echtzeitbedingung})}
\vspace*{-1.75em}
\begin{center}
	\begin{lstlisting}
	while(True) {
		Sende Ereignis in 100ms
		/* Verarbeitungszeit */
		Lese Wert ein
		Bearbeite Aufgabe
		/* Wartezeit */
		Warte auf Ereignis
	}
	\end{lstlisting}
\end{center}
\vspace*{-1.5em}

\subsection{Event Triggered}
\vspace*{-1.75em}
$\circ$ Applikation reagiert auf Ereignisse/(Software-)\textit{Interrupts}, die von anderen Tasks oder dem OS (z.B. \textit{Treiber}) generiert werden\\
$\circ$ Im Regelfall am effizientesten; Zeitbasis (\textit{isochroner Modus} von Echtzeitbuss) häufig exakter als im Betriebssystem\\
\text{$\circ$ \textit{Determinismus} hängt von zeitlicher Verteilung der externen Events ab (z.B. Überlastung des Systems wenn Benutzer ganz oft Knopf drückt)}\\
\hspace*{1em}Kein Einfluss auf Häufigkeit der Events (ggf. \textbf{nicht echtzeitfähig})
\vspace*{-1.75em}
\begin{center}
	\begin{tabular}{c|c}
		\textbf{Verfahren} & \textbf{Charakteristik}\\
		\hline
		\textit{Busy-Loop} & 100\% Auslastung, unabhängig vom Bedarfsfall\\
		\textit{Time-Triggered} & \makecell[c]{Auslastung abhängig vom gewählten Abtastintervall,\\unabhängig vom Bedarfsfall}\\
		\textit{Event-Triggered} & \makecell[c]{Auslastung abhängig vom Bedarfsfall}
	\end{tabular}
\end{center}

\end{document}