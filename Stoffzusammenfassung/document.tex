%http://de.wikipedia.org/wiki/Hilfe:TeX#Sonderzeichen_in_TeX
%http://www.kubieziel.de/computer/latex-tutorial.html
%http://www.math.uiuc.edu/~hildebr/tex/course/intro2.html
%http://en.wikibooks.org/wiki/LaTeX/Packages/Listings
%Immer document.tex oder main.tex nennen!
%http://latex.mschroeder.net/
%http://stackoverflow.com/questions/741985/latex-source-code-listing-like-in-professional-book
%http://amath.colorado.edu/documentation/LaTeX/reference/faq/bibstyles.pdf
%ftp://tug.ctan.org/pub/tex-archive/info/l2tabu/german/l2tabu.pdf
%http://amath.colorado.edu/documentation/LaTeX/reference/faq/bibstyles.html#styles
%http://www.bibtex.org/SpecialSymbols/de/
%http://amath.colorado.edu/documentation/LaTeX/reference/faq/bibstyles.html#styles
%http://www.bibtex.org/SpecialSymbols/de/
%http://en.wikipedia.org/wiki/Help:Displaying_a_formula
%mit "\input{datei}" wird die Datei "datei.tex" direkt an dieser Stelle eingefügt

\documentclass[
% *** Papiergröße und Seitenteilung ***
	openany,
	german,
	paper=a4,				%A4
					%Bindung links, aufgeschlagen von rechts
	DIV=15,					%Seitenteilung (Anzahl der Teile). Einfach mal damit spielen
							%8..15
	BCOR=-1cm,				%Binderand auf der Innenseite für die Buchbindung
% *** Formatierung/Schriftgröße/Kopf/Fußzeilenoptionen
	8pt,					%Schriftgröße 12pt
	parskip,				%kann mit einer Länge versehen werden um die Absatzgröße
							%einzustellen	
	headsepline,			%Kopfzeile über jeder Seite anlegen
	cleardoublepage=empty,	%Füllseiten sind auch wirklich "leer", also auch ohne
							%Seitennummerierung
	%,chapterprefix
% *** Einträge im Inhaltsverzeichnis (TOC) definieren ***
	bibtotoc,				%Literaturverz/Referenzen
	]{scrreprt}				%KOMA-Vorlage scrrprt

% *** KOMA-Seitenstil Kopfzeilen/Fußzeilen! ***
\setkomafont{disposition}{\rmfamily}
\usepackage{scrpage2} 		%KOMA-Seitenstil
\pagestyle{scrheadings} 	%Seitenstile von scrpage2 {KOMA} aktivieren
\automark[section]{chapter}	%Kapitel innen, Unterkapitel rechts
\clearscrheadings 			%Alle Markierungen auf den Seiten löschen
\ihead{}					%Seitenkopf innen (Bei D.seite l.Seite: r.o. und bei r.Seite:l.o)
\chead{}					%Seitenkopf mitte
\ohead{\headmark}			%Seitenkopf außen 
\ifoot{}					%Seitenfuß innen
\cfoot{}					%Seitenfuß mitte
\ofoot{\pagemark}			%Seitenfuß außen
\setlength{\headheight}{1.1\baselineskip}	%Höhe des reservierten Platzes am Seitenkopf

	
%******************************
%      Sprache und Schrift 
%******************************	
%alles für deutsche Eingabe (sonst keine Umlaute im Sourcecode möglich)   
\usepackage[latin1]{inputenc}
%\usepackage[utf8]{inputenc}
\usepackage[english,ngerman]{babel} 
\usepackage[T1]{fontenc} 	
\usepackage{lmodern}		%bessere Schrift		
%  **  Absätze  **
\parindent 0pt				%Absätze nicht von links einrücken
%Größe dynamisch anpassen, so dass auf die Seite mehr Text geht
%oder aufgeweitet wird, so dass eine angefangene Seite besser gefüllt wird
%\usepackage{setspace}		
\usepackage[onehalfspacing]{setspace}

%******************************
% ALTE SPRACHEN
%******************************
%\usepackage{ibycus4}	%altgriechisch
%\usepackage{etex}
%\usepackage{cjhebrew}		%hebräisch
%\usepackage[english]{betababel}

%\usepackage{palatino}
%\usepackage{latexsym}
%\usepackage{multirow}
%\usepackage{graphicx}


%*********************************
%	Pakete für Index/Glossar/Mathe/...
%*********************************
% ** Mathe/Formeln **
\usepackage{amsmath} 		%TeX-Mathe ermöglichen
% ** Inhaltsverzeichnis **
\usepackage{makeidx}		%wird durch \makeindex eingeleitet und
							%\printindex ausgeführt
\makeindex
% ** Bilder/Grafiken einbinden **
\usepackage{graphicx}		%Graphiken aller Art einbinden, auch eps
\usepackage{float} 			%platziert grafiken besser
% ** Links im PDF werden anklickbar **
\usepackage{hyperref}
% ** Glossar für Begriffsdefinitionen wird erstellt **
\usepackage{nomencl}		%Nomenklatur-Paket für das Glossar verwenden 
\makenomenclature			%wird durch /makenomenclature eingeleitet und mit
							%/printnomenclature ausgeführt
% ** Listings ** ->Sourcecode vorformatiert zitieren -> z Zt auf C++ eingestellt
\usepackage{listings}		%Code-Listings erlauben
\usepackage{color}			%ermöglicht Farbvorgaben, z.B. bei den Listings
\usepackage{courier}
\usepackage{caption}
\usepackage{subfig}
\usepackage{makecell}
\usepackage{titlesec}
\usepackage[default]{gfsneohellenic}
\usepackage{tikz}
\usepackage{tabularx}

%******************
%  RESERVIERT
%******************
%\usepackage{mparhack}		%evtl. notwendig, wenn Ränder buggy
%\input{Kapitel/Zusatz}	%andere Textdateien includieren

%********************************************************
%	Titel usw., auch für das PDF
%********************************************************
\title{Vorlage für eine Bachelorarbeit mit LaTeX}
\author{René Bauer}
\date{9. Mai 2011}
% ** Einträge für das erzeugte PDF **
\hypersetup{
pdfauthor = {René Bauer},
pdftitle = {Vorlage für eine Arbeit mit LaTeX}, 
pdfsubject = {Steuerungsoptimierung},
pdfkeywords = {TeX, LaTeX, pdflatex, Bachelorarbeit, Bachelorthesis, Diplomarbeit},
pdfcreator = {LaTeX with hyperref package},
pdfproducer = {dvips + ps2pdf}	%eigentlich ist es pdflatex
}
\lstset{language=C++,
	basicstyle=\ttfamily,
	keywordstyle=\color{blue}\ttfamily,
	stringstyle=\color{red}\ttfamily,
	commentstyle=\color{green}\ttfamily,
	numbers=none,
	morecomment=[l][\color{magenta}]{\#}
}


\titleformat{\chapter}[display]
{\normalfont\huge}{}{10pt}{\Large}
\titlespacing{\chapter}{0pt}{-125pt}{0pt}

\titleformat{\section}[display]
{\normalfont\huge}{}{-50pt}{\large}

\titleformat{\subsection}[display]
{\normalfont\huge}{}{-50pt}{\large}

%*********************************************
%	Fußnoten durchgehend nummerieren
%*********************************************
% - normalerweise wird je Seite oder Kapitel neu gezählt
\usepackage{chngcntr} 
\counterwithout{footnote}{chapter}

%*********************************************
% Überschriften usw neu benennen
%*********************************************
% hier ist nicht die Namensgebung und Aufnahme der
% Begriffsdefinitionen, hierfür bitte unten nachschauen!
%\renewcommand{\contentsname}{Table of contents}
%\renewcommand{\listfigurename}{List of figures}
%\renewcommand{\figurename}{Figure}
%\renewcommand{\tablename}{Table}
%\renewcommand{\listtablename}{List of tables}

%************************************************
%    HIER BEGINNT DAS EIGENTLICHE DOKUMENT
%************************************************
\begin{document}

%**************************************************************
%   unbedingt eine Seite für die spätere Bindung frei lassen!
%**************************************************************
%\newpage

%******************************************************
%                     Titelblatt
%******************************************************

\chapter{Embedded Systems}
\section{Einführung}
\subsection{Eingebettetes System}
\vspace*{-1.7em}
\begin{tabular}{lc}
	\raisebox{-.5\height}{\includegraphics[scale=0.315]{images/eingebettetes_system.png}} & \makecell[l]{
		$\circ$ integrierte, elektronische Schaltung mit spezifischer Aufgabe,\\
		\hspace*{1em}mit der ein Benutzer nur indirekt in Verbindung kommt\\
		$\circ$ Teil eines Gesamtsystems mit stark beschränkten Ressourcen,\\
		\hspace*{1em}bestehend aus Hard- und Software (teilweise ohne Betriebssystem)\\
		$\circ$ HW/SW-Codedesign z.B. mit \textit{VHDL},\\
		\hspace*{1em}allgemein \textit{tool}- bzw. \textit{modellbasierter} Entwurf\\
		$\circ$ \textit{75 \%} verwenden ein Betriebssystem (Tendenz steigend)\\
		\hspace*{1em}- \textit{25 \%} mit \textit{Main-Loop}
	}
\end{tabular}\\

\begin{tabular}{lc}
	\makecell[l]{
		$\circ$ Ist eine Kombination aus Hard- und Softwarekomponenten, die in einen technischen Kontext\\
		\hspace*{1em}zur \textit{Steuerung}, \textit{Regelung} und \textit{Überwachung} eines Systems eingebunden sind\\
		$\circ$ Es verrichtet vordefinierte Aufgaben, oftmals mit \textit{Echtzeitberechnungs}-Anforderungen\\
		$\circ$ \textbf{Speicherprogrammierbare Steuerung} (SPS): Verwendet zur Fabrikautomatisierung, Verkehrsleitung\\
		$\circ$ \textbf{Standardarchitektur} auf einem PC: Preiswerte Hardware (allerdings oft nicht \textit{industrietauglich})\\
		\hspace*{1em}preiswerte Software, häufig ohne \textit{Echtzeitfaehigkeit}\\
		$\circ$ \textbf{Industrie-PC}: Unterstützt Echtzeitbetriebssysteme
	} & \raisebox{-.5\height}{\includegraphics[scale=0.315]{images/prozessankopplung.png}}
\end{tabular}

\vspace*{-.5em}
\subsection{Definition: \textit{Technischer Prozess}}
\vspace*{-1.7em}
$\circ$ Prozess, in dem Zustandsgrößen durch \textit{technische} Hilfsmittel festgestellt und beeinflusst werden\\
\hspace*{1em}- \textit{Prozess} definiert als Gesamtheit von aufeinander einwirkenden Vorgängen in einem System, durch die Information verändert wird\\
$\circ$ \textit{Sensoren} (z.B. Thermometer, Kamera, Mikrofon) erfassen Zustandsgrößen, \textit{Aktoren} (z.B. Motoren, Relais, Ventile) beeinflussen sie

\vspace*{-.75em}
\subsection{Klassifikation: \textit{Technischer Prozess}}
\vspace*{-1.7em}
$\circ$ \textbf{Fließprozess (Regler):} physikalische Größe mit stückweise kontinuierlichem Wertebereich,\\
\hspace*{1em}ablaufende Vorgänge sind zeit- und ortsabhängig, z.B. chemische Reaktoren, Energieerzeugung in Kraftwerken\\
$\circ$ \textbf{Folgeprozess (State Machine):} Binäre, diskrete Informationselemente werden gemeldet oder ausgelöst,\\
\hspace*{1em}z.B. Ampel- oder Aufzugsteuerung\\
$\circ$ \textbf{Stückprozess (Datenbank):} Informationselemente werden einzeln identifizierbaren Objekten (Stücken) zugeordnet\\
\hspace*{1em}z.B. Transport- oder Ladevorgänge, Fertigung

\vspace*{-.75em}
\subsection{Definition: \textit{Rechenprozess}}
\vspace*{-1.7em}
$\circ$ \textit{Task} als Instanz zur dynamischen Abarbeitung eines Programms zur Berechnung von Ausgabewerten aus Eingabewerten über\\
\hspace*{1em}Umformen, Transportieren oder Speichern von Information

\vspace*{-.75em}
\subsection{Definition: \textit{Kognitiver Prozess}}
\vspace*{-1.7em}
\begin{tabular}{lc}
	\raisebox{-.5\height}{\includegraphics[scale=0.175]{images/kognitiver_prozess.png}} & \makecell[l]{
		$\circ$ Umformen, transportieren oder verarbeiten von Information im menschlichen Bediener\\
		$\circ$ Einflussnahme des Bedieners auf den Rechenprozess über \textit{Man Machine Interface} (MMI)
	}
\end{tabular}

\vspace*{-.75em}
\subsection{Definition: \textit{Steuerungssystem}}
\vspace*{-1.7em}
$\circ$ Umfasst zur Steuerung erforderliche Rechenprozesse sowie deren Hard- bzw. Software\\
$\circ$ Aufgaben:\\
\hspace*{1em}- Erfassen von Zustandsgrößen\\
\hspace*{1em}- Koordinaten \& Überwachung der Prozessabläufe

\vspace*{-.75em}
\subsection{Definition: \textit{Steuerung} und \textit{Regelung}}
\vspace*{-1.7em}
$\circ$ \textbf{Steuerung:} Kein geschlossener \textit{Regelkreis}, Rechenprozess reagiert nicht auf sich ändernde Sensorwerte im technischen Prozess\\
$\circ$ \textbf{Regelung:} Geschlossener \textit{Regelkreis}, Sensor- bzw. Messwerte werden verwendet, um Stellgrößen daraus zu berechnen

\newpage

\vspace*{-3.0em}
\subsection{Self-Hosted-Entwicklung}
\vspace*{-1.7em}
$\circ$ Entwicklungsumgebung und Zielsystem sind identisch (\textit{so wie wir es alle kennen})

\vspace*{-0.5em}
\subsection{Host-Target-Entwicklung}
\vspace*{-1.7em}
$\circ$ \textit{Self-Hosted-Entwicklung} oft nicht möglich da Hardware proprietär oder zu leistungsschwach für Entwicklungsumgebung\\
\begin{tabular}{lc}
	\raisebox{-.5\height}{\includegraphics[scale=0.225]{images/host_target_entwicklung.png}} & \makecell[l]{
		$\circ$ \textbf{Host:} Entwicklungsrechner, enthält \textit{Cross-Compiler}, \textit{Remote-Debugger}, \textit{Target-}Libraries und -Betriebssystem\\
		\hspace*{1em}- \textit{Cross-Compiler:} Erzeugt \textit{Image}, dass eigentliche Applikation sowie\\
		\hspace*{1em}\hspace*{1em}Betriebssystem- und Laufzeitkomponenten + \textit{Startupcode} enthält\\
		\hspace*{1em}- \textit{Remote-Debugger:} Auf dem Host läuft GUI mit \textit{Debug-Info}, über \textit{JTAG} etc. sieht man\\
		\hspace*{1em}\hspace*{1em}den Systemzustand des Targets (\textit{Stack}, \textit{Variablen}belegung) an gewählten \textit{Breakpoints}\\
		\hspace*{1em}- \textit{Ohne} Remote-Debugger: Konsolenausgaben per \textit{printf}, \textit{LED}s blinken lassen\\
		$\circ$ \textbf{Schnittstelle:} Zum \textit{Downloaden} der Applikation auf das \textit{Target} oder fürs \textit{Debugging},\\
		\hspace*{1em}verschiedenste Variationen möglich (z.B. \textit{Ethernet}, \textit{USB}, \textit{JTAG}, \textit{Flash}, ...)\\
		$\circ$ \textbf{Target:} System, für das entwickelt wird\\
		\hspace*{1em}- \textit{Boot-Monitor:} Programm auf dem Target, über das Software geladen und gestartet werden kann,\\
		\hspace*{1em}\hspace*{1em}erfolgt über ähnliche Schnittstellen wie die \textit{Host-Target}-Entwicklung an sich
	}
\end{tabular}

\vspace*{-1.7em}
\subsubsection{Softwareentwicklung in einem \textit{Host-Target} System}
\vspace*{-1.7em}
\begin{tabular}{lc}
	\raisebox{-.5\height}{\includegraphics[scale=0.275]{images/entwicklung_host_target.png}} & \makecell[l]{
		$\circ$ \textbf{Object File:} Symboltabelle\\
		$\circ$ \textbf{Linker:} Symbol-Auflösung und \textit{Relocation}\\
		$\circ$ \textbf{Executable File:} Code \& Daten zur Ausführung, Umsetzung auf virtuellen Speicher\\
		$\circ$ \textbf{Shared object file:} Code und Daten zum (dynamischen) linken mit anderen \textit{object files}\\
		$\circ$ \textbf{Relocatable file:} Code und Daten zum linken mit anderen \textit{object files} um Executable\\
		\hspace*{1em}zu erstellen\\
		$\circ$ \textbf{Dynamic Linker:} Laden von \textit{shared} Libraries
	}
\end{tabular}

\vspace*{-1.7em}
\subsubsection{Tools: \textit{Kernel-Tracer}}
\vspace*{-1.7em}
$\circ$ Zeigt \textit{Signale}, \textit{Task-Zustaende}, \textit{Semaphoren}, \textit{Interrupts}

\vspace*{-1.7em}
\subsubsection{Tools: \textit{Stack-Monitor}}
\vspace*{-1.7em}
\text{$\circ$ Zeigt maximal verfügbarer \textit{Stack} pro \textit{Task}, aktuelle Auslastung und maximale je gemessene Auslastung (\textit{Hochwassermarke}) des Stacks}

\vspace*{-1.7em}
\subsubsection{Weitere Tools}
\vspace*{-1.7em}
$\circ$ Anzeige der Speicherbelegung und \textit{Auslastung} der \textit{CPU}, \textit{Memory-Leak-Detection}, \textit{Code-Coverage}

\newpage

\vspace*{-2.9em}
\section{Echtzeitbetrieb}
\vspace*{-.5em}
\subsection{Kriterien für Echtzeitsysteme}
\vspace*{-1.75em}
\begin{tabular}{lc}
	\raisebox{-.5\height}{
		\begin{tikzpicture}[scale=0.67]
			\coordinate (R) at (0,0);
			\coordinate (B) at (3.5,0.01);
			\coordinate (C) at (4.1,0.01);
			
			\draw[->] (-.5,0) -- (4.2,0) node[right] {$t$};
			\draw[->] (0,-.5) -- (0,4.2) node[above] {$Auslastung$};
			\draw[-, line width=0.25mm]  (3,-.5) -- (3,4);
			\node[] at (4.67, -.5) {Echtzeitschranke};
			
			\draw[-] (R) to[out=60,in=130, distance=3cm ] (B);
			\node[] at (1.75,2.2) {Schneller PC};
			
			\draw[-] (R) to[out=40,in=140, distance=3cm ] (C);
			\node[] at (5.25,0.75) {Langsamer PC};
		\end{tikzpicture}
		} & \makecell[l]{
		$\circ$ Schnelligkeit bzw. Geschwindigkeit ist \textbf{nicht} wichtig im Kontext einer harten Echtzeitschranke\\
		\hspace*{1em}ein schnellerer PC ist zwar häufiger vor der Schranke fertig, aber eben auch nicht zu 100\%\\
		$\circ$ Wichtig dagegen sind:\\
		\hspace*{1em}- Pünktlichkeit (\textit{Ober- und Untergrenze}) bzw. Rechtzeitigkeit (\textit{Nur Obergrenze}) (\textit{timeliness})\\
		\hspace*{1em}- Verfügbarkeit\\
		\hspace*{1em}- Determinismus (bei gleicher Eingabe im gleichen Zustand liefert das System immer die\\
		\hspace*{1em}\hspace*{1em}gleiche Ausgabe)\\
		$\circ$ Verletzungen von Zeitbedingungen ggf. katastrophal (fristgerechte Bearbeitung von Anforderungen\\
		\hspace*{1em}aus einem technischen Prozess)
	}
\end{tabular}

\vspace*{-.5em}
\subsection{Vorbedingungen für Echtzeitbetrieb}
\vspace*{-1.7em}
$\circ$ Verarbeitungszeit von Aufgaben berücksichtigen, bei mehreren Aufgaben Reihenfolge der Abarbeitung planen\\
$\circ$ Reihenfolge entscheidend für fristgerechte Ergebnisse\\
$\circ$ Priorität von Aufgaben gemäß ihrer Wichtigkeit als Planungsgrundlage\\
$\circ$ Unterbrechung einer Aufgabe muss durch einen Prozess zur Bearbeitung höher-priorer Aufgaben möglich sein\\
\hspace*{1em}$\Rightarrow$ Formaler Rahmen zum Nachweis schritthaltender Verarbeitung

\vspace*{-1em}
\subsection{Echtzeitbedingung: Auslastung}
\vspace*{-1.7em}
\begin{tabular}{lc}
	\raisebox{-.5\height}{\includegraphics[scale=0.325]{images/auslastung.png}} & \makecell[l]{
		$\circ$ $t_V$ := Verarbeitungszeit\\
		$\circ$ $t_P$ := Prozesszeit, Abstand zwischen zwei Anforderungen (\textit{Jobs})\\
		\hspace*{1em}desselben Typs, wenn $t_P$ konstant handelt es sich um einen\\
		\hspace*{1em}\textit{zyklischen} bzw. \textit{periodischen} Prozess\\
		$\circ$ $\rho = \frac{t_V}{t_P}$ := Auslastung\\
		\hspace*{1em}- $\rho_A = \frac{t_{VA}}{t_{PA}}$\\
		\hspace*{1em}- $\rho_B = \frac{t_{VB}}{t_{PB}}$\\
		\hspace*{1em}- $\rho_{A+B} = \frac{t_{VA}}{t_{PA}} + \frac{t_{VB}}{t_{PB}}$\\
		$\circ$ $\rho = \sum_{i = 0}^{n}\frac{t_Vi}{t_Pi}$ := Gesamtauslastung bei $n$ Prozessen
	}
\end{tabular}
$\circ$ \textbf{1. \textit{Echtzeitbedingung:}} Gesamtauslastung aller Prozesse $\leq$ 1 $\Leftrightarrow$ $\rho = \sum_{i = 0}^{n}\frac{t_Vi}{t_Pi} \leq 1$\\

$\circ$ \raisebox{-.5\height}{\includegraphics[scale=0.425]{images/echtzeitbetrieb_beispiel.png}}

\newpage

\vspace*{-3.5em}
\subsubsection{Art von Rechenprozessen}
\vspace*{-1.7em}
$\circ$ \textit{zyklisch:} konstanter Abstand zwischen zwei Anforderungen\\
$\circ$ \textit{azyklisch:} Keine Untergrenze zwischen zwei Nachrichten, kommen beliebig (\textit{gefaehrlich})\\
$\circ$ \textit{sporadisch:} ähnlich wie \textit{azyklisch} aber mit Untergrenze zwischen zwei Nachrichten (z.B. \textit{Netzwerktreiber})

\vspace*{-1em}
\subsection{Echtzeitbedingung: Pünktlichkeit}
\vspace*{-1.7em}
\begin{tabular}{lc}
	\raisebox{-.5\height}{\includegraphics[scale=0.325]{images/puenktlich.png}} & \makecell[l]{
		$\circ$ Aufgabe darf nicht vor spezifizierten Zeitpunkt $t_{Zmin}$ erledigt sein(meist unwichtig oder \textit{trivial})\\
		$\circ$ Aufgabe muss spätestens bis Zeitpunkt $t_{Zmax}$ erledigt sein (Rechtzeitigkeit)\\
		$\circ$ Verbleibende Reaktionszeit: $t_R = t_V + t_W$ (Verarbeitungszeit + Wartezeit)\\
		\hspace*{1em}\textit{Wartezeit} := Zeit, bis Rechenkern frei ist
	}
\end{tabular}
$\circ$ \textbf{2. \textit{Echtzeitbedingung:}} Um Aufgaben rechtzeitig zu erledigen, muss die Reaktionszeit zwischen der minimal\\
\hspace*{1em}und maximal zulässigen Reaktionszeit liegen: $t_{Zmin} \leq t_{Rmin} \leq t_R \leq t_{Rmax} \leq t_{Zmax}$

\subsection{Harte und weiche Echtzeit}
\vspace*{-1.7em}
\begin{tabular}{lc}
	\raisebox{-.5\height}{
		\begin{tikzpicture}[scale=0.75]
			\coordinate (A) at (1,0);
			\coordinate (B) at (0,1);
			\coordinate (C) at (3,0);
			\coordinate (D) at (4,1);
			\coordinate (E) at (1,3);
			\coordinate (F) at (3,3);
			\coordinate (G) at (.25,3);
			\coordinate (H) at (3.75,3);
			
			\draw[->] (-.5,0) -- (4.2,0) node[right] {$t$};
			\draw[->] (0,-.5) -- (0,4.2) node[above] {$Kosten$};
			
			\draw[-] (A) node[below] {$t_{Zmin}$} -- (B);
			\draw[-] (C) -- (D)node[right] {Weiche Echtzeit};
			
			\draw[-, dotted] (A) -- (E);
			\draw[-, dotted] (C) node[below] {$t_{Zmax}$} -- (F) node[left] {$Deadline$};
			
			\draw[-] (A) to[out=95, in=-60] (G);
			\draw[-] (C) to[out=85, in=-120] (H) node[right] {Harte Echtzeit};
		\end{tikzpicture}
	} & \makecell[l]{
		$\circ$ \textit{Harte} Echtzeit: Verletzung der Rechtzeitigkeit hat \textit{katastrophale} Folgen\\
		\hspace*{1em}(z.B. Airbag, Herzschrittmacher)\\
		$\circ$ \textit{Weiche} Echtzeit: Schlechteres Ergebnis (z.B. \textit{ruckelnde} Videowiedergabe, GPS-Latenz)\\
		\hspace*{1em}$\Rightarrow$ Häufig \textit{Graubereich}\\
		$\circ$ \textit{Kostenfunktion:} Kosten \textit{explodieren} bei Überschreitung der Echtzeitschranke (\textit{Deadline})\\
		\hspace*{1em}im Falle von Harter Echtzeit, bei Weicher Echtzeit steigen Kosten nur \textit{linear} an
	}
\end{tabular}

\vspace*{-1em}
\begin{tabular}{lc}
	\makecell[l]{
		$\circ$ \textit{Nutzenfunktion:} Ergebnisse außerhalb des Intervalls $[t_{Zmin}, t_{Zmax}]$ haben bei Harter Echtzeit\\
		\hspace*{1em}nahezu \textit{keinen} Nutzen mehr, bei Weicher Echtzeit ungefähr \textit{lineare} Ab- bzw. Zunahme
	} &
	\raisebox{-.5\height}{
		\begin{tikzpicture}[scale=0.75]
			\coordinate (A) at (0,0.1);
			\coordinate (B) at (1,0.1);
			\coordinate (C) at (1,3);
			\coordinate (D) at (3,0.1);
			\coordinate (E) at (3,3);
			\coordinate (F) at (4,0.1);
			
			\draw[->] (-.5,0) -- (4.2,0) node[right] {$t$};
			\draw[->] (0,-.5) -- (0,4.2) node[above] {$Nutzen$};
			
			\draw[-, line width=0.275mm] (A) -- (B) node[below] {$t_{Zmin}$};
			
			\draw[-, line width=0.275mm] (B) -- (C);
			\draw[-, line width=0.275mm] (D) node[below] {$t_{Zmax}$} -- (E) node[left] {$Deadline$};
		
			\draw[-, line width=0.275mm] (D) -- (F);
			
			\draw[-] (A) to[out=53, in=-95] (C);
			\draw[-] (E) to[out=275, in=127] (F);

			
			\node[rotate=90] at (.3, 2.125) {Weiche Echtzeit};
			\node[rotate=90] at (3.75, 2.125) {Weiche Echtzeit};
			\node[rotate=45] at (2, 1.25) {Harte Echtzeit};
			
		\end{tikzpicture}
	}

\end{tabular}


\newpage


\vspace*{-2.5em}
\section{Echtzeitbetriebssysteme}
\vspace*{-.5em}
\subsection{Aufgaben und Anforderungen}
\vspace*{-1.7em}
$\circ$ Steuern und Überwachen: Ausführung der Benutzerprogramme \& Verteilung der Betriebsmittel (Speicher, Prozessor, Dateien)\\
$\circ$ Stellt dem Benutzer die Sicht einer einfacher als die Hardware zu bedienenden \textit{virtuellen Maschine} zur Verfügung\\
\hspace*{1em}- Aus Sicht des Benutzers steht der Rechner ihm allein zur Verfügung\\
\hspace*{1em}- Einfacher, standardisierter Zugriff auf \textit{Ressourcen} (Speicher, Geräte, Dateien per Gerätetreiber, Dateisystem, Speichermanagement)\\
$\circ$ \textbf{Zeitverhalten}\\
\hspace*{1em}- Schnelligkeit (bei einem \textit{RTOS} insbesondere Realisierung kurzer Antwortzeiten)\\
\hspace*{1em}- Zeitlicher Determinismus (Speicherverwaltung und Garbage Collection sind problematisch)\\
\hspace*{1em}\hspace*{1em}$\star$ Scheduling, IPC und Synchronisation\\
\hspace*{1em}\hspace*{1em}$\star$ Angabe und Einhalten von Zeitbedingungen, Bereitstellen von \textit{Zeitdiensten}\\
$\circ$ \textbf{Geringer Ressourcenverbrauch}\\
\hspace*{1em}- Hauptspeicher \& Prozessorzeit\\
$\circ$ \textbf{Zuverlässigkeit \& Stabilität}\\
\hspace*{1em}- Programmfehler dürfen Betriebssystem und andere Programme \textit{nicht} beeinflussen\\
\hspace*{1em}- Linux: Treiber \& Kernelmodule laufen im \textit{Kernel}-Adressraum\\
\hspace*{1em}- QNX: Mikrokernel-Architektur: sogar Treiber haben \textit{eigenen} Adressraum\\
$\circ$ \textbf{Sicherheit}\\
\hspace*{1em}- Datei- und Zugangsschutz\\
$\circ$ \textbf{Portabilität, Flexibilität und Kompatibilität von Systemkomponenten}\\
\hspace*{1em}- Erweiterbarkeit, Einhalten von Standard (z.B. \textit{POSIX})\\
\hspace*{1em}- Möglichkeit für andere Betriebssysteme, geschriebene Programme zu portieren (anpassen, übersetzen, ausführen)\\
$\circ$ \textbf{Skalierbarkeit}\\
\hspace*{1em}- Hinzunehmen oder Weglassen von Betriebssystem-Komponenten möglich machen\\
\hspace*{1em}- Geringer Programm- und Datenspeicherbedarf bei kleinen Anwendungen (\textit{Footprint})\\
\hspace*{1em}- Komfort und umfassende Funktionalität bei großen Anwendungen

\vspace*{-.5em}
\subsection{Aufbau und Struktur}
\vspace*{-1.7em}
\begin{tabular}{lc}
	\raisebox{-.5\height}{\includegraphics[scale=0.4]{images/betriebssystemkern.png}} & \makecell[l]{
		$\circ$ Ein \textit{Betriebssystem} besteht aus aufbauenden \textit{Systemkomponenten}\\
		\hspace*{1em}(Dienstprogramme, Werkzeuge) und einem \textit{Betriebssystemkern}\\
		$\circ$ $(1)$: Hardware-\textit{Interrupt}\\
		$\circ$ $(2)$: Software-Interrupt (\textit{Systemcall})\\
		$\circ$ $(3)$: Hardware-Interrupt (während eines Systemcalls)\\
		$\circ$ $(4)$: Hardware-Interrupt (\textit{Scheduler} wird aufgerufen)\\
		$\circ$ $(5)$: Scheduler übergibt CPU einem Task auf \textit{User}-Ebene\\
		$\circ$ Betriebssystem-Dienste werden fast bei jedem Betriebssystem über\\
		\hspace*{1em}Software-Interrupts (\textit{Supervisor Call} / Systemcall) angefordert
	}
\end{tabular}


\newpage


\vspace*{-2.5em}
\subsection{Prozessmanagement}
\vspace*{-1.7em}
\textbf{Unterbrechung \textit{ohne} Betriebssystem}\\
\vspace*{-1.7em}
\begin{tabular}{lc}
	\raisebox{-.5\height}{\includegraphics[scale=0.4]{images/unterbrechung_ohne_bs.png}} & \makecell[l]{
		$\circ$ $(1)$: CPU arbeitet Programm ab\\
		$\circ$ $(2)$: Interrupt während der Programmabarbeitung:\\
		\hspace*{1em}- Abarbeitung des aktuellen Befehls beenden\\
		\hspace*{1em}- Befehlszähler und Registerinhalte auf den Stack legen\\
		\hspace*{1em}- Befehlszähler auf \textit{Interrupt Service Routine} (ISR) legen\\
		$\circ$ $(3)$: \textit{ISR} rettet von ihr benötigte CPU-Register\\
		$\circ$ $(4)$: Eigentliche Interrupt-Behandlung\\
		$\circ$ $(5)$: Gerettete CPU-Register wiederherstellen\\
		$\circ$ $(6)$: Befehl \textit{Return from Interrupt:}\\
		\hspace*{1em}- Auf Stack abgelegte Register (\textit{Flags}, \textit{Befehlszaehler})\\
		\hspace*{1em}\hspace*{1em}wiederherstellen\\
		$\circ$ $(7)$: Normalen Programmablauf fortsetzen\\
		$\circ$ \textit{Softwareinterrupts (Systemcalls):}\\
		\hspace*{1em}- Benutzerprogramme fordern Dienste des Betriebssystems an\\
		$\circ$ \textit{Hardwareinterrupts:}\\
		\hspace*{1em}- Hardwarekomponenten (Systemuhr, HDD) fordern Dienste\\
		\hspace*{1em}\hspace*{1em}des Betriebssystems an
	}
\end{tabular}\\

\textbf{Unterbrechung \textit{mit} präemptivem Scheduling (Multitasking Betriebssystem)}\\
\vspace*{-1em}
\begin{tabular}{lc}
	\raisebox{-.5\height}{\includegraphics[scale=0.4]{images/unterbrechung_mit_bs.png}} & \makecell[l]{
		$\circ$ \textbf{Präemptiv} (bei RTOS): Rechnerkern wird bei\\
		\hspace*{1em}Interrupt der aktuell rechnende Task entzogen\\
		\hspace*{1em}\textit{wenn} höherpriore Task auf Interrupt reagieren muss\\
		\hspace*{1em}\hspace*{1em}- Interrupt zum Kontextwechsel\\
		\hspace*{1em}\hspace*{1em}- Retten des Kontextes des unterbrochenen\\
		\hspace*{1em}\hspace*{1em}\hspace*{1em}Prozesses $j$\\
		\hspace*{1em}\hspace*{1em}- eventuelle Auftragsbearbeitung\\
		\hspace*{1em}\hspace*{1em}- \textit{Scheduler:} Auswahl nächster Rechenprozess $i$\\
		\hspace*{1em}\hspace*{1em}- Kontext von Rechenprozess $i$ laden\\
		\hspace*{1em}\hspace*{1em}- Return zu $PC_i$\\
		\hspace*{1em}Bei Interrupt (z.B. \textit{Timer} oder \textit{I/O}) wird Scheduler\\
		\hspace*{1em}gestartet und zu höher priorem Prozess gewechselt\\
		\hspace*{1em}um obere Reaktionsschranke eines \textit{RTOS} einhalten\\
		\hspace*{1em}zu können (Interrupt-Sperre im \textit{Kernel} so kurz\\
		\hspace*{1em}wie möglich, obere Schranke einhalten \textit{wichtig})\\
		$\circ$ \textbf{Nicht-präemptiv} (normales Betriebssystem):\\
		\hspace*{1em}Scheduling nur bei Systemcall oder zeitgesteuert,\\
		\hspace*{1em}\textit{nicht} bei Interrupt
	}
\end{tabular}\\
\textbf{Task Control Block}\\
$\circ$ Beinhaltet: Priorität, Maschinenzustand (Register, Stack), Task-Zustand, Zeit-Quantum, Verwaltungsdaten für Betriebsmittel\\ \hspace*{1em}(\textit{Filedeskriptor}), Speicherabbildungstabellen für virtuellen Speicher (\textit{Prozessadressraum} $\rightarrow$ \textit{realer} Speicher (Code, Data, Stack))
\hspace*{1em}\hspace*{1em}\begin{lstlisting}[basicstyle=\small]
	char*			name;			/* task name */
	uint			status;			/* status of task */
	uint			priority;		/* task's current priority */
	uint			prioNormal;		/* task's normal priority */
	FUNCPTR			entry;			/* entry point of task */
	struct sigtcb	*pSignalInfo;	/* ptr to signal info for task */
	uint 			taskTicks;		/* total number of ticks */
	uint			taskIncTicks;	/* number of ticks in slice */
	struct __sFile	*taskStdFp[3]; int taskStd[3];	/* stdin, stdout, stderr fps / fds */
	char			**ppEnviron;	/* environment var table */
	int				envTblSize;		/* number of slots in table */
	int				nEnvVarEntries;	/* num env vars used */
	EXC_INFO excInfo; REG_SET regs;		/* exception info & register set */
\end{lstlisting}

\newpage

\textbf{Task-Zustände}\\
\begin{tabular}{lc}
	\raisebox{-.5\height}{\includegraphics[scale=0.375]{images/taskzustaende.png}} & \makecell[l]{
		$\circ$ \textbf{Tasks und Threads:}\\
		\hspace*{1em}- \textit{Leichtgewichtige Prozesse} um Aufwand für \textit{Kontextwechsel} zu minimieren\\
		\hspace*{1em}- Mehrere \textit{Threads} teilen sich fast \textit{kompletten} Task-Kontext\\
		\hspace*{1em}- Lediglich \textit{Stack} (mit Program Counter) und Thread-Status unterschiedlich\\
		\hspace*{1em}- sind effizient zu erzeugen und zu schedulen\\
		\hspace*{1em}- gemeinsamer (\textit{kein} getrennter) Prozessadressraum\\
		\hspace*{1em}- gemeinsame Betriebsmittel wie Files / Devices\\
		\hspace*{1em}- gemeinsamer \textit{globaler Speicher}, oft aus Effizienzgründen verwendet\\
		\includegraphics[scale=0.425]{images/threads.png}\\
	}
\end{tabular}

$\circ$ Thread erzeugen:
\begin{lstlisting}[basicstyle=\small]
#include <stdio.h>
void parent() {
	printf("The parent process has ID %d\n", getpid());
}
void child() {
	printf("The child process has ID %d\n", getpid());
	return;
}
int main(int argc, char **argv) {
	if( fork() != 0) {
		parent();
		wait();
	} else {
		child();
	}
	printf("Exit process %d \n", getpid());
	exit( 0 );
}
\end{lstlisting}

\vspace*{-2em}
$\circ$ $int$ $pthread\_create(pthread\_t *thread, pthread\_attr\_t *attr, void *(*start\_routine)(void*), void *arg)$:\\
\hspace*{1em}- Erzeugt neuen Thread (Einstiegsfunktion $start\_routine$ mit Argument $arg$)\\
\hspace*{1em}- Thread wird nebenläufig mit aufrufenden Thread abgearbeitet\\
\hspace*{1em}\hspace*{1em}- Beenden mit $pthread\_exit$ oder beenden von $start\_routine$\\
\hspace*{1em}- Attribute: \textit{Scheduling} (Art, Parmeter), \textit{Stack} (Größe, Adresse), \textit{JOINABLE} / \textit{DETACHED}\\
\hspace*{1em}\hspace*{1em}- \textit{JOINABLE:} \textit{Thread Control Block} wird solange aufgehoben, bis \textit{JOIN} auf diesen Thread aufgerufen wird\\
\hspace*{1em}\hspace*{1em}- \textit{DETACHED:} \textit{TCB} wird direkt nach Beendigung des Threads weggeworfen\\
$\circ$ $void$ $pthread\_exit(void *retval)$:\\
\hspace*{1em}- Beendigung des Threads mit $retval$\\
\hspace*{1em}- Alternative zu Beenden der $start\_routine$\\
\hspace*{1em}- Cleanup-Handler aufrufen (Ressourcen freigeben (Speicher, Filedeskriptor))\\
$\circ$ $int$ $pthread\_join(pthread\_t thread, void **thread\_return)$:\\
\hspace*{1em}- Aufruf blockiert, bis Thread sich beendet (Ergebnis steht dann in $thread\_return$)\\
$\circ$ $int$ $pthread\_detach(pthread\_t th)$:\\
\hspace*{1em}- Wenn keiner auf Thread wartet, räumt er sich bei Beendigung komplett auf (Thread Deskriptor, Stack)

\newpage

\vspace*{-2.7em}
\subsection{Speichermanagement}
\vspace*{-1.7em}
\begin{tabular}{lc}
	\raisebox{-.5\height}{\includegraphics[scale=0.375]{images/mmu.png}} & \makecell[l]{
		$\circ$ Aufgaben einer \textit{Memory-Management-Unit} (MMU): Speicherschutz \& Adressumsetzung\\
		$\circ$ \textit{MMU} ist in Hardware implementiert und wird durch das Betriebssystem\\
		\hspace*{1em}mittels \textit{Speicherabbildungstabellen} konfiguriert\\
		$\circ$ \textbf{Speicherschutz:}\\
		\hspace*{1em}- Jeder Prozess (\textbf{nicht} Thread) hat eigenen Prozessadressraum\\
		\hspace*{1em}- Zugriff nur auf eigene \textit{Daten}-, \textit{Stack}- und \textit{Code}segmente\\
		\hspace*{1em}- Zugriff auf \textit{nicht} abgebildete Adresse führt zur Interrupt (\textit{Segmentation Fault}) durch \textit{MMU}
	}
\end{tabular}

\textbf{Speicherverwaltung \textit{ohne} MMU / \textit{Adressumsetzung}}\\
$\circ$ Alle Programme sind zur \textit{Link}-Zeit bekannt, Linker kann unterschiedliche Adressbereiche pro Programm zuordnen und\\
\hspace*{1em}\textit{Sprungadressen} (d.h. Funktionsaufrufe) auflösen, es gibt ein Executable (\textit{Image})\\
$\circ$ Wenn mehrere Programme dynamisch zur Laufzeit in den Hauptspeicher geladen werden sollen:\\
\hspace*{1em}- unterschiedliche, zur \textit{Lade}-Zeit festgelegte Programmadressen (Sprünge bei Funktionsaufrufen)\\
\hspace*{1em}- Der \textit{Loader} ersetzt Adressen zur \textit{Lade}-Zeit eines Programms (z.B. Ersetzen des Symbols einer Funktion $printf()$ durch Adresse,\\
\hspace*{1em}\hspace*{1em}unter der Funktion tatsächlich verfügbar durch Symboltabelle - erst zur \textit{Ladezeit} bekannt)\\
\hspace*{1em}- Verwendung von \textit{Position Independent Code} (PIC) da natürlich zur \textit{Compile}-Zeit absolute Sprünge nicht bekannt\\
\hspace*{1em}\hspace*{1em}\textit{PIC} bedeutet die Verwendung von \textit{Relativsprüngen} (d.h. anstatt absoluter Sprung von $0x900 \rightarrow 0x1000$ wird relativer\\
\hspace*{1em}\hspace*{1em}Sprung um $0x100$ eingetragen)

\textbf{Speicherverwaltung \textit{mit} \textit{Adressumsetzung}}\\
$\circ$ Einheitlicher, \textit{virtueller} Adressraum für Programme:
\vspace*{-1.25em}
\begin{itemize}
	\setlength\itemsep{-1.25em}
	\item beginnt bei 0, umfasst kompletten adressierbaren (Adressbusbreite) Adressbereich \textit{für jedes Programm}
	\item Linker legt virtuelle Adressen in \textit{Executable} fest, Adressen werden nicht verändert, nur durch \textit{MMU} auf reale abgebildet\\
	$\rightarrow$ schnelles Laden da keine Veränderung des Executables erforderlich (nur initiale Konfiguration der MMU)
	\item Verwendung von \textit{Shared Libraries:} Mehrere \textit{Tasks} teilen sich (Code-) Segment\\
	$\rightarrow$ beliebige, virtuelle Adresse durch Linker vergeben, Abbildung auf bereits geladene Shared Library durch MMU\\
	$\Rightarrow$ Reduziert Hauptspeicherbedarf
	\item Physikalischer Adressraum meist \textit{kleiner} als virtueller Adressraum
	\item Abbildung durch \textit{Swappen} (=Auslagern des zugeordneten, physikalischen Speichers eines \textit{gesamten} Prozesses auf HDD)
	\item Abbildung durch \textit{Paging} (=Auslagern selten genutzter Speicherseiten (4kByte-\textit{Pages}) auf HDD)
	\item Swappen und Paging führen zu \textbf{Nichtdeterminismus}, für \textit{Echtzeitbetriebssysteme} also ungeeignet\\
	\text{$\rightarrow$ Es ist nicht deterministisch, wann \& wie lange eine Page geswapped wird, auch nicht, wie lange das Laden aus HDD in RAM dauert}
\end{itemize}

\textbf{Adressabbildung}\\
$\circ$ Virtuelle Adresse (z.b. \textit{32}-Bit lang) besteht aus zwei Teilen: \textit{Seitendeskriptoradresse} [31:12] und \textit{Seitenoffset} [11:0]\\
\hspace*{1em}- Seitenoffset (Adresse innerhalb einer 4kByte \textit{Page}) ist äquivalent zur physikalischen Adresse\\
\hspace*{1em}- Über den \textit{Seitendeskriptor} wird die Adressierung der \textit{Page} vorgenommen\\
\hspace*{1em}- \textit{Seitendeskriptor} enthält \textit{Zugriffsrechte} [15:12] und tatsächliche \textit{Page}-Nummer [11:0], Zugriffsrechte-Flags:\\
\hspace*{1em}\hspace*{1em}- \textbf{Schreibflag:} $1 :=$ Page darf geschrieben werden, $0 :=$ Schreibzugriff führt zu \textit{Bus-Error}\\
\hspace*{1em}\hspace*{1em}- \textbf{Datenflag:} $1: =$ Page darf gelesen werden, $0 :=$ Lesezugriff führt zu \textit{Bus-Error}\\
\hspace*{1em}\hspace*{1em}- \textbf{Codezugriff:} $1 :=$ Prozessor darf \textit{Pageinhalt} als Befehl ausführen, $0 :=$ Versuch, Inhalt als Code auszuführen führt zu \textit{Bus-Error}\\
\text{\hspace*{1em}\hspace*{1em}- \textbf{Validflag:} $1 :=$ Seite ist im Hauptspeicher, $0 :=$ Seite ausgelagert $\rightarrow$ \textit{Seite-Fehlt-Hardware-Interrupt} $\rightarrow$ \textit{Kernel} lädt Seite von HDD}

\newpage

\vspace*{-2.7em}
\subsection{I/O}
\vspace*{-1.7em}
$\circ$ Aufgaben:
\vspace*{-1.25em}
\begin{itemize}
	\setlength\itemsep{-1.25em}
	\item Aus \textbf{Applikationssicht:} Schnittstelle für einheitlichen Zugriff auf unterschiedlichste Hardware-Ressourcen
	\item Aus \textbf{Hardwaresicht:} Umgebung, um Hardware einfach \& systemkonform in Kernel zu integrieren
	\item \textbf{Zusätzlich:} Realisiert Organisationsstrukturen auf Hintergrundspeicher (\textit{Filesystem})
\end{itemize}

\vspace*{-1.25em}
$\circ$ Schnittstellenfunktion:
\vspace*{-1.25em}
\begin{itemize}
	\setlength\itemsep{-1.25em}
	\item \textit{Peripherie}-Zugriffe abgebildet durch:\\
	- Lesen und Schreiben (\textit{read} und \textit{write}): $read(fd, buf, count);$ bzw. $write(fd, \&value, sizeof(value));$\\
	- Konfigurieren und Einstellen der Betriebsart per $ioctl(fd, request, ...)$\\
	- Öffnen und Schließen (\textit{open} und \textit{close})\\
	\hspace*{1em}- \textit{Open}-Funktion des Gerätetreibers wird aufgrund der \textit{System}-Call Parameter ausgewählt (z.B. \textit{serielle},  \textit{parallele},\\
	\hspace*{1em}\hspace*{1em}oder \textit{analoge} Schnittstelle): Gerät als Pfad mit Dateinamen, Zugriffsart per Flag angeben; gibt \textit{Descriptor} als Referenz zurück\\
	\hspace*{1em}\hspace*{1em}$fd = open('Tuer', O\_RDWR);$\\
	\hspace*{1em}- \textit{Close}-Funktion gibt \textit{Ressource} wieder frei: $close(fd);$
	\item Anforderung einer \textit{Ressource} beim Betriebssystem ggf. Ablehnen aufgrund:\\
	- fehlender Zugriffsrechte\\
	- Ressource bereits belegt
\end{itemize}

\vspace*{-1.25em}
\textbf{Realisierung von \textit{Treibern}}:\\
$\circ$ \textit{Device} wird mit Namen sowie primären- und sekundären \textit{Identifier} angelegt: $mknod /dev/carrera$ $240$ $0$\\
\hspace*{1em}- Führt dazu, dass primären Identifier eine Funktion $init\_module()\{...\}$ zum Initialisieren einer $struct$ $carrera\_table$ zugeordnet wird.\\
\hspace*{1em}\hspace*{1em}Diese Struktur enthält \textit{Funktionspointer} zu \textit{Treiberfunktionen} wie $carrera\_open()\{...\}$, $carrera\_close\{...\}$, $carrera\_write()\{...\}$\\
$\circ$ Codezeile $open('/dev/carrera', O\_RDWR);$ führt dazu, dass die bei $/dev/carrera$ bzw. in $carrera\_table$ hinterlegte Funktion\\
\hspace*{1em}aufgerufen wird: $carrera\_open()\{...\}$\\
\text{$\circ$ Entfernen eines \textit{Device}s per $rmmod$ $carrera$: es wird Funktion $cleanup\_module()\{...\}$ aufgerufen, die Zeichenkette $/dev/carrera$ wieder freigibt}

\vspace*{-1.25em}
\textbf{Warum Gerät nicht aus Applikation heraus ansteuern?}
\vspace*{-1.25em}
\begin{itemize}
	\setlength\itemsep{-1.25em}
	\item Einheitliche Ressourcenverwaltung von Interrupts \& I/O-Bereiche
	\item Kapseln systemkritischer Teile\\
	- Hardwarezugriffe aus Applikation erfordern Abbildung der HW-Adressen in Prozessadressraum\\
	- Hardwarezugriffe sind \textit{sicherheitskritisch} $\rightarrow$ nur innerhalb eines Treibers durchführen\\
	- Programmierfehler könnten zum Absturz des gesamten Systems führen
	\item Überführen des Geräts in sicheren Zustand bei Applikationsfehlern\\
	- Treiber sind nach Applikationsfehler im BS noch vorhanden\\
	- Gerät wird bei Beendigung einer Applikation automatisch durch Treiber freigegeben\\
	- Bei \textit{sicherheitskritischen} Systemen wesentlich!
\end{itemize}

\vspace*{-1.25em}
\textbf{Gerätezugriff im Betriebssystem-Kern}\\
\vspace*{-1.25em}
\begin{tabular}{lc}
	\raisebox{-.5\height}{\includegraphics[scale=0.475]{images/geraetezugriff.png}} & \makecell[l]{
		$\circ$ Geräte-Schnittstelle wird von Applikation benutzt während\\
		\hspace*{1em}Treiber Funktionen realisieren, die von \textit{Kernel} selbst\\
		\hspace*{1em}aufgerufen werden (z.B. \textit{ISR}s oder Funktionen in\\
		\hspace*{1em}\textit{Kernel}- oder \textit{Timer}-Queues)\\
		$\circ$ \textbf{Ziele:} - Verkürzung der \textit{ISR}-Zeit, da währenddessen weitere\\
		\hspace*{1em}\hspace*{1em}Interrupts gesperrt\\
		\hspace*{1em}- Verkürzen der Zeit im \textit{System-Call} (z.B. durch\\
		\hspace*{1em}\hspace*{1em}\textit{Kernel-Thread}, der nur im \textit{Kernel} abgearbeitet\\
		\hspace*{1em}\hspace*{1em}wird und solange läuft, bis er sich schlafen legt\\
		\hspace*{1em}\hspace*{1em}oder seine Funktion mit $return$ verlässt - höchste Prio)\\
		\hspace*{1em}- Periodische Vorgänge in Treibern ermöglichen ( \textit{Polling})\\
		$\circ$ \textbf{Top Half:} wird gleich im Interrupt ausgeführt (befüllen der \\
		\hspace*{1em}\textit{Kernel-Queue})\\
		$\circ$ \textbf{Bottom Half:} wird in \textit{Kernel-Queue zurückgestellt}\\
		\hspace*{1em}- Kernel-Queue wird abgearbeitet, bevor $return$ in \textit{User Space}\\
		$\circ$ \textbf{Kernel-Queue:} Liste an (Treiber-)Funktionen, die der Kernel\\
		\hspace*{1em}in bestimmten Zuständen abarbeitet, z.B. $open(...)$ \\
		\hspace*{1em}oder $init\_module(...)$\\
		$\circ$ Linux-Kernel wird aufgerufen:\\
		\hspace*{1em}- Nach Abarbeitung aller Interrupts (auch \textit{Bottom Half},\\
		\hspace*{1em}\hspace*{1em}hochpriore User-Threads auch Vorrang)\\
		\hspace*{1em}- Vor Scheduling \& bei jedem Tick der Systemuhr
	}
\end{tabular}

\newpage

\textbf{Gerätezugriff im Betriebssystem-Kern}\\
$\circ$ \textit{Timer-Queue:} Liste aus Paaren $(Treiberfunktion$, $Zeitpunkt)$: Zum Zeitpunkt wird Treiberfunktion abgearbeitet\\
$\circ$ \textit{Big Kernel Lock:} Während etwas im Kernel ausgeführt wird, sind alle \textit{ISR}s gesperrt, gibt es heute nicht mehr

\vspace*{-1.25em}
\textbf{Latenzzeit}\\
\begin{tabular}{lc}
	\raisebox{-.5\height}{\includegraphics[scale=0.325]{images/latenz.png}} & \makecell[l]{
		$\circ$ \textbf{Reaktionszeit:} $t_R = t_V + t_W$ (Verarbeitungs- + Wartezeit)\\
		$\circ$ \textbf{Hardware-Latency:} Zeit bis Hardware-Ereignis als Interrupt über Bus der CPU\\
		\hspace*{1em}gemeldet wird (wenige \textit{Gatterlaufzeiten}, im $ns$-Bereich)\\
		$\circ$ \textbf{Preemption-Delay:} \textit{OS} im kritischen, nicht unterbrechbaren\\
		\hspace*{1em}Abschnitt (Interrupts gesperrt, bei Standard-OS ca. $10ms$)\\
		$\circ$ \textbf{ISR:} Verarbeitungszeit der \textit{Interrupt-Service-Routine} (\textit{Systemanteil}),\\
		\hspace*{1em}bei \textit{QNX} mit 200MHz Pentium: $1.4\mu s$\\
		$\circ$ \textbf{System Call:} Verzögerung wenn Interrupt während eines \textit{System-Call}s auftritt,\\
		\hspace*{1em}System-Call fertig stellen oder abbrechen (bei Standard-OS viele $ms$)\\
		$\circ$ \textbf{Scheduling:} Bei \textit{QNX} mit 200MHz Pentium: $2.9\mu s$\\
		$\circ$ \textbf{Context-Switch:} Aufwand, um anderen Task weiterzubearbeiten (sehr variable)\\
		$\circ$ Schließlich Weiterbearbeitung höher priorer Tasks
	}
\end{tabular}

\vspace*{-1.25em}
\textbf{Filesysteme}\\
$\circ$ Bei \textit{Embedded Systems} kaum Festplatten, viel eher:\\
\hspace*{1em}- \textit{RAM}-Filesysteme (beim Starten aus persistentem Speicher geladen, beim Beenden zurückgeschrieben)\\
\hspace*{1em}- \textit{EEPROM}, \textit{Flash} oder \textit{Solid State Drive}s\\
$\circ$ Organisation mit Filesystemen wie \textit{FAT}, \textit{NTFS}, \textit{Ext3}\\
\hspace*{1em}- schneller Zugriff \& wenig Overhead für Verwaltungsinformationen\\
$\circ$ Verwendung von \textit{Caches}:\\
\hspace*{1em}- Daten temporär inkonsistent, kein zeitlicher Determinismus bei Zugriff (man weiß nicht, wann und ob welcher\\
\hspace*{1em}\hspace*{1em}Speicherbereich im Cache liegt)\\
\hspace*{1em}- \textit{Sync-Mode} $\rightarrow$ keine Verwendung von Caches sondern explizit synchronisieren

\vspace*{-1.25em}
\textbf{Synchronisation}\\
$\circ$ \textbf{Zugriffszeit}: Zeit zwischen Auftrag und Erfüllung des Auftrags, Mechanismen zur Synchronisation von Prozessen mit Gerätezugriff\\
$\circ$ \textbf{Synchroner Zugriff}: implizites Warten, auf Gerät wartender \textit{Task} wird schlafen gelegt bis:\\
\hspace*{1em}- Gerät antwortet, Fehlersituation (z.B. \textit{Timeout}) eintritt oder \textit{Task} ein \textit{Signal} erhält\\
$\circ$ \textbf{Asynchroner Zugriff}: explizites Warten, Zugriff auf Gerät kehrt sofort zurück:\\
\text{\hspace*{1em}- Task kann weiterarbeiten; Mitteilung durch OS an Task via Polling / Ereignis (\textit{Signal}) / \textit{Callback}-Funktion: Task holt Ergebnis ab}\\
\hspace*{1em}- \textbf{Probleme:}\\
\hspace*{1em}\hspace*{1em}- Mehrere Aufträge können gleichzeitig vorliegen, Dienste müssen sich daher auf selben Auftrag beziehen können\\
\hspace*{1em}\hspace*{1em}- ggf. wird \textit{Dienstkette} $\{$ Auftragstatus ermitteln $\}$ $\rightarrow$ $\{$ Ergebnis holen $\}$ nicht bis zum Ende einer Applikation beendet\\
\hspace*{1em}\hspace*{1em}- Zustandsverwaltung im OS erforderlich\\
\hspace*{1em}- async. Zugriff mit \textbf{nicht}-blockierenden Diensten:\\
\hspace*{1em}\hspace*{1em}- Leseauftrag $\rightarrow$ Warten auf Ergebnis $\rightarrow$ Ergebnis holen (Polling, Signal / Schlafen, Signal / Callback)\\
\hspace*{1em}\hspace*{1em}- Höhere Performance (Audio, Video, Netzwerk, Datenbanken) + besseres Antwortverhalten\\
\hspace*{1em}\hspace*{1em}- Umgesetzt über Funktionen wie $aio\_read$, $aio\_write$, $aio\_fsync$ (z.B. Sync. zwischen Cache und Festplatte)\\
\hspace*{1em}- async. Zugriff \textbf{mit} Thread und \textbf{blockierendem} Aufruf:\\
\hspace*{1em}\hspace*{1em}- Thread erzeugen $\rightarrow$ im Thread blockierend auf Ressource zugreifen $\rightarrow$ Thread-Ende abwarten\\
\text{\hspace*{1em}\hspace*{1em}- Beim gleichzeitigen Warten auf mehrere Kanäle verwenden, Flag $O\_NONBLOCK$ um Gerät via $open(...)$ nicht-blockierend zu öffnen}\\
$\circ$ \textbf{Nicht blockierender Aufruf} (ähnlich zu blockierendem Lesezugriff):\\
\hspace*{1em}- Liefert Ergebnis sofort wenn vorhanden, liefert andernfalls $\{$ Nichts zum Lesen vorhanden $\}$

\subsection{Zeitdienste}
\vspace*{-1.7em}
\text{$\circ$ \textbf{Aufgaben:} zyklische Interruptgenerierung, Zeitmessung, Watchdog (\textit{Zeitüberwachung}), Zeitsteuerung für Dienste}\\
\hspace*{1em}- Realisierung über \textit{Realzeituhren} / \textit{Timer}, sind \textbf{nicht} kontinuierlich sondern \textbf{diskret}\\

\vspace*{-1.7em}
\textbf{Zyklische Interruptgenerierung}\\
$\circ$ \textbf{Systemzeit} (Ticks):\\
\hspace*{1em}- Timer generiert zyklisch (z.B. alle $1 ms$) Interrupt, zugehörige \textit{ISR}:\\
\hspace*{1em}\hspace*{1em}- ruft Scheduler auf, bearbeitet zeitabhängige Systemdienste (\textit{Weckrufe}), dient als \textit{Softwaretimer}\\
\hspace*{1em}- Genauigkeit hängt von Zeitbasis ab\\
$\circ$ Zyklische Bedienung von Interface-Karten (Taktgenerierung durch Bus-Controller)

\newpage

\textbf{Zeitmessung}\\
$\circ$ Zuordnung hochgenauer Zeitstempel zu Ereignissen\\
$\circ$ Berechnung von Geschwindigkeiten über Differenzzeitmessung (z.B. Fahrzeuge mit Lichtschranken)

\vspace*{-1.25em}
\textbf{Watchdog} (Zeitüberwachung):\\
$\circ$ Zur Überwachung der Einhaltung von Echtzeitbedingungen\\
$\circ$ Zur Zeitüberwachung einfacher Dienste (Datenausgabe, Peripherie)\\
$\circ$ Zur Zeitüberwachung von Systemkomponenten, User-Interaktionen (\textit{Totmann} in Lokomotiven) oder des gesamten Systems\\
$\circ$ Mechanismus:\\
\hspace*{1em}- System muss in regelmäßigen Abständen einen rückwärts laufenden Timer zurücksetzen (d.h. Startwert neu setzen)\\
\hspace*{1em}- Wenn System in undefiniertem Zustand und unfähig, Zähler zurückzusetzen, läuft dieser auf Null $\rightarrow$ löst \textit{Interrupt} aus:\\
\hspace*{1em}\hspace*{1em}- Alarm / Fehlermeldung\\
\hspace*{1em}\hspace*{1em}- Systemreset (entweder zuerst noch \textit{ISR} aufrufen und dann CPU-Reset oder direkt CPU-Reset)\\
\hspace*{1em}\hspace*{1em}- \textbf{Problem:} Es gibt Momente, in denen \textit{ISR}s nicht ausgeführt werden (Interrupt Sperre), daher lieber direkt Reset!\\
$\circ$ \textbf{Erstellen:} $WDOG\_ID$ $wdCreate$ $(void)$, \textbf{Löschen:} $wdDelete$ $(WDOG\_ID)$, \textbf{Starten:} $wdStart$ $(WDOG\_ID$, $delay$, $FUNCPTR$, $param)$,\\
\hspace*{1em}\textbf{Abbrechen:} $wdCancel(WDOG\_ID)$

\vspace*{-1.25em}
\textbf{Zeitsteuerung für Dienste}:\\
$\circ$ Ausführen spezifischer Aufgaben in regelmäßigen Abständen (Backups, Messwerte erfassen)

\vspace*{-1.25em}
\textbf{Zeitgeber}:\\
$\circ$ \textit{Absolut}-Zeitgeber: Uhren (\textit{clocks}), \textit{Relativ}-Zeitgeber: Timer (\textit{timer})\\
$\circ$ Realisierung in Hardware oder per Software via \textbf{Vorwärtszähler} / \textbf{Rückwärtszähler}\\
\hspace*{1em}- \textbf{repetitive} Zähler: Zählwert wird nach Ablauf (Zählerstand = 0) selbstständig neu geladen\\
\hspace*{1em}- \textbf{single shot} Zähler: expliziter Neustart erforderlich

\vspace*{-1.25em}
\textbf{Zugriff auf Zeitdienste - Hardwarelevel}:\\
$\circ$ \textit{Zeit-bezogene} Hardware: Echtzeituhren (Absolutzeitgeber), Frequenzteiler, Vor- und Rückwärtszähler, Watchdog\\
$\circ$ \textbf{Absolutzeitgeber:} Stellen Absolutzeit ($HH:mm:ss:ms$ $TT.MM.YYYY$) bereit, \textit{batteriegepuffert},\\
\hspace*{1em}möglichst genau bei \textit{verteilten} Echtzeitsystemen

\vspace*{-1.25em}
\textbf{Zugriff auf Zeitdienste - Kernellevel}:\\
$\circ$ Zyklische Timerinterrupts im Betriebssystemkern:\\
\hspace*{1em}- Treiber können Tasks für variable Dauer in $\{$ wartend $\}$ versetzen\\
\hspace*{1em}- Module können zyklischen oder einmaligen (zu einem Relativzeitpunkt) Funktionsaufruf zulassen\\
$\circ$ \textbf{Vorsicht} bei Realzeit im Kernel (Sekunden statt Ticks): Abstand zwischen zwei Ticks kann von System zu System variieren\\
$\circ$ \textbf{Zählerüberlauf:} Muss in allen Schichten geprüft werden - um darauf basierende Fehler möglichst früh zu erkennen:\\
\hspace*{1em}$\rightarrow$ relative Zeit wird auf kurz vor Überlauf des Timers gesetzt!

\vspace*{-1.25em}
\textbf{Zugriff auf Zeitdienste - Userlevel}:\\
\text{$\circ$ Absolutzeitanfragen z.B. mit $gettimeofday()$, um Prozess / Thread für definierte Zeit in Zustand $\{$ wartend $\}$ versetzen: $sleep(seconds)$}

\vspace*{-1.25em}
\textbf{Kritische Punkte}: in \textit{Kernelebene:} Relativzeit führt zu Zählerüberlauf; in \textit{User-Ebene:} Sommer-/Winterzeit, Schalttage, Zeitzone

\vspace*{-1.25em}
\textbf{Zeitdrift}:\\
\text{$\circ$ Durch ungenaue Uhren, ungenaue Start-Systemzeit $\rightarrow$ \textit{Zeitsynchronisation} mit Broadcastmessages eines \textit{Zeitservers} (\textit{Mikrosekundenbereich})}\\
\hspace*{1em}- Synchronisation mit \textit{Network Time Protocol} (NTP) / DCF77 / statistische Berechnungen

\vspace*{-1.25em}
\textbf{Zeitkorrektur}:\\
$\circ$ \textbf{Problem:} Sprunghafte Korrektur von Absolutzeiten\\
\hspace*{1em}- Zurückstellen: Zeitpunkte kommen doppelt vor\\
\hspace*{1em}- Vorstellen: Zeitpunkte werden übersprungen\\
\text{$\Rightarrow$ Abbremsen/Beschleunigen der Systemuhr: $adjtimex(struct$ $timex)$, keine doppelten/fehlenden Zeitpunkte, Zeit vergeht langsamer/schneller}\\
$\circ$ Durch Downtime (Serverupdate) entfallen geplante Aktionen $\rightarrow$ durchgeführte Aktionen protokollieren und bei Neustart nachholen

\vspace*{-1.25em}
\textbf{Repräsentation von Zeit}:\\
$\circ$ Absolutzeit: $struct$ $time\_t$ (Jahr, Wochentag, Monat, Tag, Stunde, Minute, Sekunde)\\
$\circ$ Absoluttimer: $struct$ $timespec$ $\{tv\_sec$, $tv\_nsec\}$\\
$\circ$ Relativzeiten und Zeitpunkte für Timer: $struct$ $itimerspec$ $\{it\_interval$, $it\_value\}$\\
\hspace*{1em}- $it\_interval$ $\neq 0$: Timer startet Intervallweise, $it\_value$ $\neq 0$: Timer startet einmal in Absolutzeit $it\_value$\\
\hspace*{1em}- $it\_interval$ $\neq 0$ \textbf{und} $it\_value$ $\neq 0$: Timer startet im Zeitpunkt $it\_value$ Intervallweise mit $it\_interval$

\vspace*{-1.25em}
\textbf{API für Zeitdienste}:\\
$\circ$ Prozess für $n$ $ns$ schlafen legen: $nanosleep(timespec$ $request$, $timespec$ $remainder\_after\_signal)$\\
\text{$\circ$ Uhrzeit abfragen/setzen/Auflösung: $clock\_gettime(clockid\_t$, $timespec)$\textbf{/}$clock\_settime(clockid\_t$, $const$ $timespec)$\textbf{/}$clock\_getres(clockid\_t$, $timespec)$}\\
\text{$\circ$ Timer erzeugen/löschen/Ablauf: $timer\_create(clockid\_t$, $sigevent$, $timer\_t)$\textbf{/}$timer\_delete(timer\_t)$\textbf{/}$timer\_settime(timer\_t$, $itimerspec$ $val$, $itimerspec$ $remain)$}

\newpage

\vspace*{-2.5em}
\section{Programmiertechniken bei Echtzeitbetriebssystemen}
\subsection{Verschiedene Programmiersprachen}
\vspace*{-1.75em}
$\circ$ \textbf{Assembler:} selten, bei zeitkritischen Anwendungen; \textbf{C:} \textit{Die} Programmiersprache für \textit{Embedded Systems}\\
\hspace*{1em}\textbf{C++:} Seltener als C, tiefes Wissen für Effizient erforderlich; \textbf{ADA:} Schöne, typsichere Sprache, schwer \textit{hardwarenah} programmierbar\\
\hspace*{1em}\textbf{Java:} weit verbreitet, hohe Produktivität, \textit{aber:} nicht deterministisch durch Garbage-Collection / Memory-Management $\rightarrow$ \textit{RT}-Java

\subsection{Endliche Zustandsautomaten (\textit{Finite State Machines})}
\vspace*{-1.75em}
\begin{tabular}{lc}
	\raisebox{-.5\height}{\includegraphics[scale=0.4]{images/zustandsautomat.png}} & \makecell[l]{
		$\circ$ Weit verbreitetes \textit{Paradigma} bei Ereignis-orientierten Systemen\\
		$\circ$ Bestehen aus einer Anzahl an \textbf{Zuständen}, \textbf{Ereignissen}, \textbf{Transitionen} \& \textbf{Ausgaben}\\
		$\circ$ System befindet sich zu \textit{einer} Zeit in genau \textit{einem} Zustand\\
		$\circ$ Eintretendes Ereignis führt zu Zustandsübergang in einen \textit{Folgezustand}\\
		$\circ$ Übersichtlich Implementierbar: allgemeiner Interpreter (\textit{switch-case}) oder Beschreibung (\textit{Automatentafel})\\
		$\circ$ Geeignet für \textbf{digitale} (also \textit{diskrete}) Ereignisse bzw. Zustände (\textbf{nicht} für analoge, kontinuierliche Zustände)\\
		$\circ$ Überprüfung des \textit{Abdeckungsgrades} als auch der Laufzeit (deterministisch) möglich
	}
\end{tabular}

\subsection{Richtlinien zur Entwicklung eingebetteter Systeme}
\vspace*{-1.75em}
$\circ$ Zerlegung einer Aufgabe auf mehrere (\textit{konkurrierende} und \textit{kooperierende}) Tasks zur schritthaltenden Verarbeitung (\textit{Multitasking})\\
$\circ$ Unterbrechbarkeit (\textit{Preemption}) der Tasks\\
$\rightarrow$ \textbf{Kontrollfluss:} Synchronisation zwischen Tasks mit \textit{Semaphore} \& Events\\
$\rightarrow$ \textbf{Datenaustausch:} Inter-Prozess-Kommunikation (\textit{IPC}) zwischen Tasks\\
$\rightarrow$ \textbf{Scheduling:} Priorisierung der Tasks

\subsection{Kontrollfluss am Beispiel der \textit{Pathfinder Mars-Mission}}
\vspace*{-1.75em}
\begin{tabular}{lc}
	\raisebox{-.5\height}{\includegraphics[scale=0.3275]{images/pathfinder_01.png}} & \makecell[l]{
		$\circ$ \textbf{Z-Task:} Periodische Zustandsüberwachung (Temperatur, Ströme),\\
		\hspace*{1em}hat \textbf{mittlere} Priorität\\
		$\circ$ \textbf{M-Task:} Erfassung meteorologischer Messwerte, hat \textbf{niedrigste}\\
		\hspace*{1em}Priorität\\
		$\circ$ \textbf{Bus-Management-Task:} Datenaustausch über Informations-Bus,\\
		\hspace*{1em}hat \textbf{höchste} Priorität\\
		$\circ$ \textbf{RK:} Belegung des Rechnerkerns\\
		$\circ$ \textbf{S:} Wert der \textit{Semaphore} für den Informationsbus\\
		$\circ$ \textbf{Konkurrierende Prozesse:} \textit{M}- und \textit{B}-Task \textit{konkurrieren} um\\
		\hspace*{1em}Zugriff auf Daten (sind \textbf{nicht} disjunkt)\\
		$\circ$ \textbf{Kooperierende Prozesse:} Prozess liefert Daten für anderen\\
		\hspace*{1em}(\textit{Erzeuger}-\textit{Verbraucher}-\textit{Modell}) - ebenfalls \textbf{nicht} disjunkt\\
		$\circ$ \textbf{Disjunkte Prozesse:} Ablauf eines Prozesses/Threads\\
		\hspace*{1em}unabhängig von anderen (ebenfalls disjunkten) Prozessen\\
		$\Rightarrow$ Die Wirkung der gegenseitigen Beeinflussung von \textit{nicht}\\
		\hspace*{1em}disjunkten, parallelen Prozessen ohne Synchronisation ist \textit{nicht}\\
		\hspace*{1em}vorhersagbar und im Regelfall auch \textit{nicht} reproduzierbar
	}
\end{tabular}

\subsection{Kritischer Bereich}
\vspace*{-1.75em}
\textbf{Race Condition}\\
$\circ$ Unsynchronisierter Zugriff mehrerer Threads bzw. auf Prozesse auf \textit{dieselben} Daten:
\vspace*{-1.25em}
\begin{itemize}
	\setlength\itemsep{-1.25em}
	\item Ergebnis/Konsistenz vom Prozessfortschritt abhängig (z.B. \textit{Ringpuffer}) $\rightarrow$ Race conditions \textit{unbedingt} vermeiden
	\item \text{Lösung: \textit{Gegenseitiger Ausschluss} (Mutual Exclusion) $\rightarrow$ höchstens \textit{ein} Prozess tritt in kritischen Abschnitt ein, abgesichert durch \textbf{Mutex}}
\end{itemize}

\vspace*{-1.75em}
\noindent\begin{minipage}{.45\textwidth}
	\begin{lstlisting}[caption=Prozess 1,frame=tlrb]{Name}
	i := read(counter); /* Liest 0 */
	/* Context-Switch zu Prozess 2 */
	i++;
	write(counter, i);
	/* Schreibt ebenfalls 1 zurück */
	\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.45\textwidth}
	\begin{lstlisting}[caption=Prozess 2,frame=tlrb]{Name}
	i := read(counter); /* Liest 0 */
	i++;
	write(counter, i);
	/* Schreibt 1 zurück*/
	\end{lstlisting}
\end{minipage}

\newpage

\vspace*{-2.75em}
\textbf{Binäre Semaphore vs Mutex}\\
$\circ$ Binäre Semaphore (hat Werte 0 \& 1): exklusive Verwendung zum Erzeugen von Ereignisses im Erzeuger-Verbraucher-Problem\\
$\circ$ Mutex: exklusive Verwendung als \textit{Rekursiver Mutex}:\\
\hspace*{1em}- Wenn der Prozess bereits einen Mutex inne hat, der bei einem weiteren kritischen Abschnitt (z.B. über einen Funktionsaufruf)\\
\hspace*{1em}\hspace*{1em}wieder benötigt wird, darf der Prozess eintreten, da er den Mutex ja bereits besitzt. Das erste Freigeben des Mutex\\
\text{\hspace*{1em}\hspace*{1em}(z.B. am Ende der aufgerufenen Funktion) ist nicht wirksam, er besitzt ja immer noch den Mutex für den ersten kritischen Abschnitt},\\
\hspace*{1em}\hspace*{1em}erst nach dem Verlassen diesen Abschnitts wird der Mutex freigegeben:

\vspace*{-1.75em}
\noindent\begin{minipage}{.45\textwidth}
	\begin{lstlisting}[caption=Funktion 1,frame=tlrb]{Name}
	func init() {
		lock();
		/* do something */
		unlock();
	}
	\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.45\textwidth}
	\begin{lstlisting}[caption=Funktion 2,frame=tlrb]{Name}
	func main() {
		/* Mutex initial genommen */
		lock();
		init();
		/* Mutex wieder freigeben */
		unlock();
	}
	\end{lstlisting}
\end{minipage}

\vspace*{-1.75em}
\textbf{Semaphore}\\
$\circ$ Synchronisationswerkzeug: Zur Signalisierung bei Erzeuger/Verbraucher (Erzeuger \textit{gibt} Semaphore, Verbraucher \textit{nimmt} Semaphore)\\
$\circ$ Bei gegenseitigem Ausschluss: Semaphore nehmen bei Betreten und geben bei Verlassen\\
$\circ$ \textit{Integer}-Variable, wir zu Beginn auf Maximalwert $N$ initialisiert (= Anzahl Prozesse, die kritischen Bereich betreten dürfen)\\
\text{$\circ$ \textbf{P-Operation} (Semaphore nehmen): Bei Zugriff auf Semaphore wird Wert um 1 verringert \& Prozess schlafen gelegt, falls Wert negativ}\\
\text{$\circ$ \textbf{V-Operation} (Semaphore geben): Bei Freigabe einer Semaphore wird Wert um 1 erhöht \& ein wartender Prozess geweckt, falls Wert $\leq 0$}


\subsection{Kritischer Bereich und Prioritätsinversion am Beispiel der \textit{Pathfinder Mars-Mission}}
\vspace*{-1.75em}
\begin{tabular}{lc}
	\raisebox{-.5\height}{\includegraphics[scale=0.3275]{images/pathfinder_02.png}} & \makecell[l]{
		$\circ$ Niedrig-priore $M-Task$ läuft, belegt Semaphore\\
		$\circ$ Hoch-priore $B-Task$ fängt an zu laufen, erkennt, dass Semaphore belegt\\
		\hspace*{1em}$\rightarrow$ legt sich wieder schlafen\\
		$\circ$ $Z-Task$ läuft an, verdrängt $M-Task$ aufgrund höherer Priorität, läuft bis fertig\\
		$\circ$ Anschließend läuft zuvor gelaufener $Z-Task$ wieder an, nach einiger Zeit gibt\\
		\hspace*{1em}es \textit{Watchdog}-Error da $B-Task$ zu lange nicht drann kam\\
		$\circ$ \textbf{Prioritätsinversion:}\\
		\hspace*{1em}- Tasks unterschiedlicher Priorität: \textbf{Hoch} ($B-Task$), \textbf{Mittel} ($Z-Task$),\\
		\hspace*{1em}\hspace*{1em}\textbf{Niedrig} ($M-Task$)\\
		\hspace*{1em}- \textbf{Hoch} \& \textbf{Niedrig} mit gemeinsamen, kritischen Bereich\\
		\hspace*{1em}- \textbf{Niedrig} ist im kritischen Bereich, wenn \textbf{Hoch} ebenfalls betreten will\\
		\hspace*{1em}- \textbf{Hoch} wartet, bis \textbf{Niedrig} Bereich wieder verlässt\\
		\hspace*{1em}- \textbf{Mittel} verdrängt \textbf{Niedrig} $\rightarrow$ \textbf{Hoch} muss auf\\
		\hspace*{1em}\hspace*{1em}Beenden von \textbf{Mittel} warten\\
		\hspace*{1em}$\Rightarrow$ \textbf{Mittel} ist somit höherprior als \textbf{Hoch}
	}
\end{tabular}

\textbf{Lösung der Prioritätsinversion durch Prioritätsvererbung (\textit{Priority Inheritance Protocol})}\\
$\circ$ Sobald \textbf{Hoch} kritischen Bereich betreten will, ist es wichtig, dass dieser wieder freigegeben wird, \textbf{Niedrig} aber \textit{zu unwichtig}\\
$\circ$ Lösung: Priorität von \textbf{Hoch} auf \textbf{Niedrig} für die Zeit der Abarbeitung des kritischen Bereiches übertragen\\
$\circ$ \textbf{Allgemein:} Falls Job \textbf{Hoch} Semaphore anfordert, welche gegenwärtig von Job \textbf{Niedrig} gehalten wird, dann wird Priorität von \textbf{Niedrig}\\
\hspace*{1em}auf die Priorität von \textbf{Hoch} angehoben, sobald der Job \textbf{Niedrig} Semaphore wieder freigibt, bekommt er initiale Priorität zurück

\vspace*{-1.25em}
\textbf{Lösung der Prioritätsinversion durch \textit{Priority Ceiling Protocol}}\\
\text{$\circ$ Anheben der Priorität des Tasks \textbf{Niedrig} auf Priorität des höchstprioren Tasks, mit dem er sich Ressourcen teilt (kann Deadlocks verhindern)}\\
$\circ$ Schwer zu implementieren da kritische Bereiche und Tasks, die diese verwenden, dem Scheduler bekannt sein müssen

\vspace*{-1.25em}
\textbf{Deadlock}\\
$\circ$ \textit{Critical Sections} können zu Verklemmungen (\textit{Deadlocks}) führen (\textbf{Task A} ruft $P(S_1)$ auf, \textbf{Task B} ruft $P(S_2)$ auf,\\
\hspace*{1em}\textbf{Task A} wartet nun auf $S_2$, \textbf{Task B} auf $S_1$

\vspace*{-1.25em}
\textbf{Schreib-/Lese Locks}\\
$\circ$ Race-Condition nur dann kritisch, wenn Rechenprozesse Daten \textit{modifizieren}, reines \textit{Lesen} unkritisch $\rightarrow$ \textit{Spezielle Semaphore} erlauben\\
\hspace*{1em}\text{parallelen Lesezugriff, Schreibzugriff \textbf{nur} exklusiv: Rechenprozess teilt bei Anforderung des Mutexes mit, ob er Lesen oder Schreiben will}\\

\newpage

\hspace*{1em}\textbf{1.} Kritischer Abschnitt frei $\rightarrow$ Zugriff gewährt\\
\hspace*{1em}\textbf{2.} Lesender Prozess belegt Critical Section $\rightarrow$ Schreibender Prozess wird blockiert, lesender zugelassen\\
\hspace*{1em}\textbf{3.} Schreibender Prozess belegt Critical Section $\rightarrow$ Prozess wird abgewiesen, egal ob lesend oder schreibend

\vspace*{-1.25em}
\textbf{Weitere Schutzmaßnahmen}\\
$\circ$ Semaphore \textbf{nur} zum Schutz kritischer Abschnitte für Prozesse im \textbf{User-Bereich}\\
$\circ$ Kernel-Ebene: \textbf{Unterbrechungsschutz} (Interrupts für die Zeit des Zugriffs auf kritischen Abschnitt sperren, Latenzzeiten kurz halten)\\
$\circ$ Kernel-Ebene bei \textit{Multiprozessorsystemen} (mehrere \textit{ISR}s können \textit{echt parallel} bearbeitet werden, \textit{Unterbrechungsschutz} hilft nicht):\\
\text{\hspace*{1em}\textbf{Spinlock}: Gemeinsame Variable entscheidet, ob Critical Section betreten werden darf (\textit{Busy waiting} - Polling eines Flags, falls besetzt)}\\
\hspace*{1em}\hspace*{1em}- Spinlock kehrt im Einprozessorsystem nicht zurück - \textbf{nicht verwenden}

\vspace*{-1.5em}
\begin{center}
	\begin{tabular}{c|c|c|c}
		\textbf{Methode} & \textit{User Level} & \textit{Einprozessorsystem}: Kernel Level & \textit{SMP}: Kernel Level\\
		\hline
		Unterbrechungssperre & Nein & Ja & Nein\\
		Spinlock & Nein & Nein & Ja\\
		Semaphore & Ja & Ja & Ja
	\end{tabular}
\end{center}

\subsection{Events}
\vspace*{-1.75em}
$\circ$ Task wartet auf ein Event (Ereignis), andere Task setzt/signalisiert Event (mit \textit{Semaphore} oder \textit{Message-Queue} realisiert)

\subsection{Condition Variable}
\vspace*{-1.75em}
$\circ$ Ist ein \textit{Event}, das an die Änderung einer Bedingung (z.B. Überschreiten eines Puffer-Füllständes) geknüpft ist, \textbf{3 Dinge} zusammen:\\
\hspace*{1em}- \textbf{Condition Variable} := Event, wenn Bedingung sich ändert\\
\hspace*{1em}- \textbf{Global (shared) Variable} := Variable, über die Bedingung formuliert ist\\
\hspace*{1em}- \textbf{Mutex} := sichert Bereich $\{$ Überprüfen der Bedingung/Warten auf Veränderungssignal $\}$ ab

\vspace*{-1em}
\begin{center}
	\begin{lstlisting}[basicstyle=\small]
		pthread_mutex_t spar_lock;
		pthread_cond_t spar_aenderung;
		unsigned int erspartes;
		
		void ausgeben(int menge) {
			pthread_mutex_lock(&spar_lock);
			while(erspartes < menge) {
				/* gibt 'spar_lock' frei, damit einzahlen überhaupt
				 * möglich ist, ansonsten gäbe es 'Deadlock'
				 */
				pthread_cond_wait(&spar_aenderung, &spar_lock);
			}
			erspartes -= menge;
			pthread_mutex_unlock(&spar_lock);
		}
		
		void einzahlen(int menge) {
			pthread_mutex_lock(&spar_lock);
			erspartes += menge;
			pthread_cond_broadcast(&spar_aenderung);
			pthread_mutex_unlock(&spar_lock);
		}
	\end{lstlisting}
\end{center}

\vspace*{-1.75em}
\subsection{Signale}
\vspace*{-1.75em}
$\circ$ \textit{Signal} führt zu Unterbrechung des Programmablaufs innerhalb einer Applikation:\\
\hspace*{1em}- Programm wird abgebrochen ($exit()$)\\
\hspace*{1em}- Programm reagiert mit implementierten $Signal-Handler()$ (ähnlich zu einer \textit{Interrupt-Service-Routine})\\
$\circ$ \textit{Signal} kann ausgelöst werden durch:\\
\hspace*{1em}- Programm\\
\hspace*{1em}- Ereignisse innerhalb des Betriebssystems selbst: Zugriff auf nicht vorhandenen Speicherbereich ($\rightarrow$ \textit{Segmentation-Fault-Signal}\\
\hspace*{1em}- ggf. Abfangen um noch wichtige Daten zu sichern

\vspace*{-1.75em}
\begin{center}
	\begin{tabular}{c|c}
		\textbf{Signale} & \textbf{Events}\\
		\hline
		\makecell[c]{Kommen \textit{asynchron} zum Programmablauf\\werden \textit{asynchron} verarbeitet} & \makecell[c]{Kommen \textit{synchron} zum Programmablauf\\werden \textit{synchron} verarbeitet}\\
		Ähnlich zu \textit{Interrupt-Service-Routine} & \textit{Rendezvous}-Charakter
	\end{tabular}
\end{center}

\newpage

$\circ$ \textbf{Signale} führen außerdem zum sofortigen Abbrechen eines gerade aktiven, blockierenden \textit{System-Calls}\\
$\rightarrow$ Jeden Systemcall überprüfen, ob durch Signal unterbrochen ($errno$ $=$ $EINTR$) \& \textit{neu} aufsetzen falls ja\\
$\circ$ $sigaction(signum$, $struct$ $sigaction$ $*act$, $sigaction)$: $*act$ enthält Adresse des \textit{Signal-Handlers}, der bei Signal von OS aufgerufen wird\\
$\circ$ $kill(pid\_t$, $sig)$: einem \textit{Task} oder einer \textit{Task-Gruppe} wird ein Signal geschickt

\subsection{Message Queues}
\vspace*{-1.75em}
$\circ$ Zum Transport von Daten zwischen Tasks (\textit{Inter-Prozess-Kommunikation})\\
$\circ$ Daten mit unterschiedlicher, nach oben begrenzter Größe von Task $A$ nach Task $B$ senden\\
$\circ$ Über Filesystem mit $Namen$, \textit{task-intern} per \textit{Message Queue ID} identifiziert\\
$\circ$ Blockierendes Senden (Queue voll) \& Empfangen (Queue leer)

\subsection{Shared Memory}
\vspace*{-1.75em}
$\circ$ Gemeinsamer Speicherbereich (= globale Variable(n)), Realisierung \textit{trivial} - aber \textit{Critical Section} nicht vergessen\\
$\circ$ Realisierung z.B. über OS-Filesystem, da Speicheradresse von Task zu Task unterschiedlich sein kann, sollte sie innerhalb von\\
\hspace*{1em}Datenstrukturen relativ zu Beginn des Speicherbereichs angegeben werden

\subsection{Sockets}
\vspace*{-1.75em}
$\circ$ Kommunikation über Rechnergrenzen hinweg (aber auch \textit{lokal}) möglich\\
$\circ$ Verbindung identifiziert über $Rechnername[IP]$ + $Port$-$Nummer$: \textit{Server} öffnet Port (bei TCP zusätzlich Handshake),\\
\hspace*{1em}\textit{Client} öffnet Verbindung \& sendet an Server

\subsection{Busy-Loops}
\vspace*{-1.75em}
$\circ$ Echtzeitsteuerung ist nur mit der Regelung \textbf{eines einzigen} technischen Prozesses beschäftigt ($volatile$ bei Pollen nicht vergessen)\\
$\circ$ Rechnerprozess pollt ständig technischen Prozess nach Anforderungen; ist einfach programmierbar, kein OS nötig, sehr häufig vertreten
\vspace*{-1.75em}
\begin{center}
	\begin{lstlisting}
	while(True) {
		Lese Wert ein
		Bearbeite Aufgabe
		Warte (100ms)
	}
	\end{lstlisting}
\end{center}
\vspace*{-1.5em}

\subsection{Time-Triggered}
\vspace*{-1.75em}
$\circ$ Applikation prüft zyklisch, ob bestimmte Bedingung erfüllt ist (Zeitbasis aus dem Betriebssystem, Peripherie ist \textbf{rein passiv}\\
\text{$\circ$ Abtastzeit so kurz wählen, dass: kein Zustand verloren geht (\textit{Abtasttheorem}) / Reaktion rechtzeitig erfolgen kann (\textbf{2. Echtzeitbedingung})}
\vspace*{-1.75em}
\begin{center}
	\begin{lstlisting}
	while(True) {
		Sende Ereignis in 100ms
		/* Verarbeitungszeit */
		Lese Wert ein
		Bearbeite Aufgabe
		/* Wartezeit */
		Warte auf Ereignis
	}
	\end{lstlisting}
\end{center}
\vspace*{-1.5em}

\subsection{Event Triggered}
\vspace*{-1.75em}
$\circ$ Applikation reagiert auf Ereignisse/(Software-)\textit{Interrupts}, die von anderen Tasks oder dem OS (z.B. \textit{Treiber}) generiert werden\\
$\circ$ Im Regelfall am effizientesten; Zeitbasis (\textit{isochroner Modus} von Echtzeitbuss) häufig exakter als im Betriebssystem\\
\text{$\circ$ \textit{Determinismus} hängt von zeitlicher Verteilung der externen Events ab (z.B. Überlastung des Systems wenn Benutzer ganz oft Knopf drückt)}\\
\hspace*{1em}Kein Einfluss auf Häufigkeit der Events (ggf. \textbf{nicht echtzeitfähig})
\vspace*{-1.75em}
\begin{center}
	\begin{tabular}{c|c}
		\textbf{Verfahren} & \textbf{Charakteristik}\\
		\hline
		\textit{Busy-Loop} & 100\% Auslastung, unabhängig vom Bedarfsfall\\
		\textit{Time-Triggered} & \makecell[c]{Auslastung abhängig vom gewählten Abtastintervall,\\unabhängig vom Bedarfsfall}\\
		\textit{Event-Triggered} & \makecell[c]{Auslastung abhängig vom Bedarfsfall}
	\end{tabular}
\end{center}

\newpage

\vspace*{-2.75em}
\subsection{Programmierstil}
\vspace*{-1.75em}
$\circ$ Zeitkritische Tasks mit \textbf{möglichst wenig} Systemaufrufe\\
$\circ$ Zeitaufwändige Aufgaben in eigene Tasks auslagern $\Rightarrow$ Werden durch Scheduling des Threads in einzelne Aufgaben zerlegt\\
$\circ$ Rekursion vermeiden \textbf{da Stack stark beschränkte Ressource} ist $\Rightarrow$ iterativ programmieren\\
$\circ$ Keine Schleifen die im schlimmsten Fall \textbf{endlos} auf Event warten $\Rightarrow$ Abbruchbedingung mit maximaler Anzahl an Durchläufen\\
$\circ$ Datenstrukturen statisch oder zur Initialisierungszeit allozieren - nicht erst zur Laufzeit $\Rightarrow$ \textbf{kein \textit{new}}\\
\hspace*{1em}- nicht-deterministisches Verhalten der Speicherverwaltung \& eventuell kein Speicher mehr verfügbar\\
$\circ$ Rückgabewerte von Funktionen und Return-Codes grundsätzlich \textbf{im kompletten Definitionsbereich} auswerten

\newpage

\vspace*{-2.5em}
\section{Echtzeitnachweis}
\subsection{Aufbau und Eigenschaften}
\vspace*{-1.75em}
$\circ$ Formaler Nachweis, dass \textbf{1. \& 2. Echtzeitbedingung} erfüllt ist\\
$\circ$ Man geht vom \textbf{schlimmst-möglichen Fall} aus\\
\hspace*{1em}- Prozess- bzw. Zykluszeiten möglichst kurz\\
\hspace*{1em}- Verarbeitungszeit möglichst lang\\
\hspace*{1em}- Alle Ereignisse treten gleichzeitig auf ($t = 0$)\\
$\circ$ Ablauf\\
\hspace*{1em}- Relevante Kenndaten des Prozesses ermitteln\\
\hspace*{1em}\hspace*{1em}- Anforderungen, Minimale Prozesszeit, Minimale \& Maximale Reaktionszeit $t_{Zmin}$, Abhängigkeiten zwischen Ereignissen\\
\hspace*{1em}- Maximale Verarbeitungszeit $t_{Vmax}$ (\textbf{WCET}) für jede Anforderung\\
\hspace*{1em}- Auslastungsbedingung überprüfen\\
\hspace*{1em}- Rechtzeitigkeitsbedingung verifizieren (Bestimmung von $t_{Rmin}$ \& $t_{Rmax}$)

\subsection{Abschätzen der \textit{Worst Case Execution Time}: Messen}
\vspace*{-1.75em}
$\circ$ Messen durch Anweisungen im Code \begin{lstlisting}
while(true) {
	/* Warten auf Ereignis */
	Zeitstempel t1 setzen
	/* Verarbeitung */
	Zeitstempel t2 setzen
}
\end{lstlisting}
\hspace*{1em}- Vorteile: Sprachunabhängig \& einfach realisierbar\\
\hspace*{1em}- Nachteile\\
\hspace*{1em}\hspace*{1em}- Aussagekraft der Messung abhängig von vielen Randbedingungen (Cache, Prozesszustand, Schleifen)\\
\hspace*{1em}\hspace*{1em}- Theoretisch wären sämtliche Kombinationen aus Inputdaten erforderlich (100\% Test-Abdeckung)\\
\hspace*{1em}\hspace*{1em}- Produktiver Code auf Zielplattform (erst spät in der Entwicklung) oder Simulator erforderlich

\subsection{Abschätzen der \textit{Worst Case Execution Time}: Analyse}
\vspace*{-1.75em}
$\circ$ Aus Quellcode wird Strukturgraph des Codestücks erstellt, mit Beschreibung der Hardware wird längster Pfad durch Graphen gesucht\\
\hspace*{1em}- Vorteile\\
\hspace*{1em}\hspace*{1em}- Analyse auch nach Codemodifikation schnell durchführbar\\
\hspace*{1em}\hspace*{1em}- Frühzeitig ohne Zielhardware möglich\\
\hspace*{1em}\hspace*{1em}- Größtmögliche Abdeckung des Inpus\\
\hspace*{1em}- Nachteile\\
\hspace*{1em}\hspace*{1em}- Komplexe Analysewerkzeuge erforderlich\\
\hspace*{1em}\hspace*{1em}- Verifikation der Ergebnisse (stimmmt die Hardwarebeschreibung?)

\subsection{Abschätzen der \textit{Best Case Execution Time} (BCET)}
\vspace*{-1.75em}
$\circ$ Erforderlich wenn Codesequenz nicht vor einer minimal zulässigen Reaktionszeit $t_{Zmin}$ abgearbeitet worden sein darf\\
$\circ$ BCET = kürzester Pfad im Strukturgraphen\\
$\circ$ Im Gegensatz zur WCET misst man bei möglichst geringer Systemlast

\newpage

\vspace*{-2.5em}
\subsection{Grafische Bestimmung der maximalen Reaktionszeit $t_{Rmax}$}
\vspace*{-1.75em}
$\circ$ Kürzere Prozesszeit entspricht höhere Priorität (\textbf{Rate Monotonic}), d.h. der Prozess mit der längsten Prozesszeit ist derjenige,\\
\hspace*{1em}mit der geringsten Priorität\\
$\circ$ Bekannt sein muss\\
\hspace*{1em}- zulässige Reaktionszeiten $t_{Zmin}$ und $t_{Zmax}$ für jeden Job\\
\hspace*{1em}- Verarbeitungszeiten $t_v$, BCET und WCET für jeden Job\\
$\circ$ Voraussetzung: \textbf{prioritätengesteuertes (preemptives) Scheduling} \& Ereignisse sind \textbf{unabhängig} voneinander\\
$\circ$ \begin{tabular}{lc}
	\raisebox{-.5\height}{\includegraphics[scale=0.3]{images/grafischer_echtzeitnachweis.png}} & \makecell[l]{
		$\circ$ \textbf{X-Achse:} Zeit\\
		$\circ$ \textbf{Y-Achse:} Noch zu erbringende Rechenzeit $S(t)$\\
		\hspace*{1em}- S = aktuelle Systemlast\\
		$\circ$ Rechenzeitanforderungen im Falle des \textit{Worst Case}\\
		$\circ$ Bei ungestörter Abarbeitung bildet sich eine mit Steigung $-1$ fallende Gerade\\
		$\circ$ Bei jeder Anforderung wird die Gerade um Verabeitungszeit $t_v$ nach oben verschoben\\
		$\circ$ Der Schnittpunkt der Gerade mit der X-Achse entspricht der \textbf{maximalen Reaktionszeit} des\\
		\hspace*{1em}\textbf{niedrigpriorsten} Prozesses\\
		$\circ$ Um maximale Reaktionszeit des nächst-niedrigprioren Prozesses zu erhalten: X-Achse um $t_v$ des\\
		\hspace*{1em}niedrigprioreren Prozesses \textbf{nach oben} verschieben\\
		$\circ$ Zu jedem Zeitpunkt lässt sich ablesen, wie viel Rechenarbeit noch zu leisten ist
	}
\end{tabular}

$\circ$ Es reicht aus, den Graph \textbf{eine Hyperperiode} lang zu betrachten, da dies der maximale Zyklus ist, ab dann beginnt alles von vorne\\
\hspace*{1em}- Eine Hyperperiode ist das kleinste gemeinsame Vielfache der Prozesszeiten aller Prozesse

$\circ$ \begin{tabular}{lc}
	\raisebox{-.5\height}{\includegraphics[scale=0.3125]{images/beispiel_echtzeitnachweis.png}} & \makecell[l]{
		$\circ$ \textbf{Job-1:} $t_v = 0.5ms$, $t_p = 1ms$\\
		$\circ$ \textbf{Job-2:} $t_v = 2ms$, $t_P = 5ms$\\
		$\circ$ Bei \textbf{4ms} ist der erste Schnittpunkte des Graphen mit der X-Achse, d.h. die\\
		\hspace*{1em}maximale Reaktionszeit für den niedrigpriorsten Prozess (= Job-2) ist 4ms,\\
		\hspace*{1em}da $4 < 5$ \textbf{ist das System echtzeitfähig}\\
		$\circ$ Die \textbf{Hyperperiode} ist $kgV(1, 5) = 5$, d.h. das System muss\\
		\hspace*{1em}maximal 5ms betrachtet werden
	}
\end{tabular}

\newpage

$\circ$ Beispiel für \begin{tabular}{|l|l|l|l|l|}
	\hline
	\textbf{Anforderung} & $t_v$ & $t_p$ & $t_{Zmax}$ & $t_{Zmin}$\\
	\hline
	1 & 10ms & 30ms & 30ms & 0ms\\
	2 & 15ms & 45ms & 45ms & 0ms\\
	3 & 15ms & 60ms & 60ms & 0ms\\
	\hline
\end{tabular} mit einer \textbf{Hyperperiode} $kgV(30, 45, 60) = 180ms$\\
\begin{tikzpicture}[yscale=-1, scale=1.5] 
	% 4x4 grid
	\draw[step=0.25] (0, 0) grid (8, -4);
	% origin point
	\draw [color=blue, fill=blue] (0, 0) circle (0.05);
	% x-axis
	\draw [thick,->] (0, 0) -- (8.5, 0);
	% y-axis
	\draw [thick,->] (0, 0) -- (0, -4.5);
	% x-axis label
	\node at (9.5, 0.0) {t in ms};
	% y-axis label
	\node at (0, -5) {$S(t)$};
	
	\draw[line width = 0.45mm, -, color=black!30!green] (0, 0) -- (0, -2.0);
	\draw[line width = 0.45mm, -, color=black!30!green] (0, -2.0) -- (1.5, -0.5);
	\draw[line width = 0.45mm, -, color=black!30!green] (1.5, -0.5) -- (1.5, -1);
	\draw[line width = 0.45mm, -, color=black!30!green] (1.5, -1) -- (2.25, -0.25);
	\draw[line width = 0.45mm, -, color=black!30!green] (2.25, -0.25) -- (2.25, -1);
	\draw[line width = 0.45mm, -, color=black!30!green] (2.25, -1) -- (3, -0.25);
	\draw[line width = 0.45mm, -, color=black!30!green] (3, -0.25) -- (3, -1.5);
	\draw[line width = 0.45mm, -, color=black!30!green] (3, -1.5) -- (4.5, 0.0);
	\draw [color=blue, fill=blue] (4.5, 0) circle (0.05);
	
	\draw[line width = 0.45mm, -, color=black!30!blue] (0.0, -0.75) -- (8, -0.75);
	\draw [color=blue, fill=red] (1.25, -0.75) circle (0.05);
	
	\draw[line width = 0.45mm, -, color=black!30!red] (0.0, -1.5) -- (8, -1.5);
	\draw [color=blue, fill=blue] (0.5, -1.5) circle (0.05);
\end{tikzpicture}

$\circ$ Durch den Schnittpunkt des grünen Graphen mit der X-Achse bei $t = 90ms$ ergibt sich für die maximale\\
\hspace*{1em}Reaktionszeit für Job-3 = 90ms, da $90ms > 60ms$ ist das System \textbf{nicht echtzeitfähig}\\
$\circ$ Die blaue Gerade ist die Verschiebung der X-Achse nach oben, wenn Job-3 nicht berücksichtigt wird\\
\hspace*{1em}- die maximale Reaktionszeit für Job-2 = 25ms, da $25ms < 45ms$ ist das System \textbf{echtzeitfähig}\\
$\circ$ Die rote Gerade ist die Verschiebung der X-Achse, wenn weder Job-3 noch Job-2 berücksichtigt werden\\
\hspace*{1em}- die maximale Reaktionszeit für Job-1 = 10ms, da $10ms < 30ms$ ist das System \textbf{echtzeitfähig}

\subsection{Hinreichende Schedulingbedingung}
\vspace*{-1.75em}
$\circ$ Voraussetzungen\\
\hspace*{1em}- Scheduling mit statischen Prioritäten (\textbf{Rate Monotonic}) - wie oben\\
\hspace*{1em}- Zyklische Tasks ohne Abhängigkeiten\\
\hspace*{1em}- $t_{Zmax} = t_p$\\
\hspace*{1em}- Falls $t_{Zmax} < t_p$: Maximal zulässige Reaktionszeit durch entsprechende\\
\hspace*{1em}\hspace*{1em}Prozesszeit modellieren: $min(t_{Zmax}, t_p)$\\
$\circ$ Aussage: Falls Bedingung für Auslastung erfüllt, wird jeder Task innerhalb seiner Prozesszeit fertig, somit ist \textbf{Rechtzeitigkeit erfüllt}\\
\hspace*{1em}- Falls nicht, kann die Rechtzeitigkeit eventuell trotzdem erfüllt sein\\
\hspace*{1em}- Es ist dann keine genauere Analyse (graphisch, mathematisch) erforderlich
$$\mu = \sum_{k = 1}^{i} \frac{t_{Vk}}{min(t_{Zmax}, t_{Pk})} \leq i\cdot (2^{\frac{1}{i}} - 1)$$
$\circ$ Mit zunehmender Prozesszahl $i\rightarrow \infty$ nähert sich die Auslastungsgrenze \textbf{69.3\%} an
\begin{center}
	\raisebox{-.5\height}{\includegraphics[scale=0.165]{images/hinreichende_schedulingbedingung.png}}
\end{center}

\newpage

\vspace*{-2.5em}
\section{Scheduling}
\vspace*{-1.75em}
$\circ$ Zu gegebenen Paaren \textit{(Anforderung, Zeit)} soll Reihenfolge der Abarbeitung gefunden werden, sodass für alle\\
\hspace*{1em}die \textbf{Rechtzeitigkeitsbedingung erfüllt ist}\\
$\circ$ \textbf{Scheduling Points:}  Scheduler prüft, ob anderer Prozess CPU erhalten sollte und veranlasst ggf. Kontextwechsel\\
\hspace*{1em}- Am Ende einer Systemfunktion (Übergang Kernel/User Mode): In Systemfunktion sind Prioritäten geändert worden\\
\hspace*{1em}- Durch Interrupts: Timer- oder I/O Interrupt\\
$\circ$ \textbf{Bewertungskriterien}\\
\hspace*{1em}- Gerechtigkeit (Jeder Prozess erhält \textit{fairen} CPU-Anteil)\\
\hspace*{1em}- Effizient (möglichst gute Auslastung der CPU)\\
\hspace*{1em}- Durchlaufzeit (Prozess so schnell wie möglich abschließen)\\
\hspace*{1em}- Durchsatz (so viele Jobs wie möglich ausführen)\\
\hspace*{1em}- Antwortzeit (möglichst schnelle Reaktion auf Ereignisse) - wichtig bei Echtzeit-Betriebssystem!\\
\hspace*{1em}- Determinismus (Scheduling soll \textit{berechenbar} sein) - wichtig bei Echtzeit-Betriebssystem!
\subsection{Statisches Scheduling}
\vspace*{-1.75em}
$\circ$ \textit{Fahrplan}, der im Vorhinein festgelegt wird - festes Schema, nach dem die einzelnen Rechenprozesse abzuarbeiten sind\\
$\circ$ Verwendet für zyklische, sicherheitskritische Anwendungen mit fixen Zeitpunkten (z.B. Flugzeug-Steuerung)\\
$\circ$ Formaler Nachweis der Einhaltung von Realzeitbedingungen möglich

\subsection{Dynamisches Scheduling}
\vspace*{-1.75em}
$\circ$ Rechenprozesse erhalten den Prozessor aufgrund der jeweils aktuellen Bedarfssituation\\
$\circ$ Rechenprozesse müssen unterbrechbar (\textit{praeemptiv}) sein

\subsection{Beispiel}
\vspace*{-1.75em}
$\circ$ \textbf{Task 1:} Alle 1500ms Messdaten aufnehmen ($t_p = 1500$ms), muss nach 400ms abgeschlossen sein ($t_{Zmax} = 400$ms)\\
$\circ$ \textbf{Task 2:} Messergebnisse innerhalb von $t_{Zmax} = 1100$ms zur Erde weiterleiten - alle 60s ($t_p = 60000$ms)\\
$\circ$ \textbf{Task 3:} Alle 200ms nach Start der Messdatenaufnahme soll Experiment angestoßen werden, die Vorbereitungen dafür müssen\\
\hspace*{1em}spätestens 500ms später abgeschlossen sein ($t_{Zmax} = 500$ms) - also 700ms nach dem Start der Messwertaufnahme. $t_p = 1500$ms\\
$\circ$ Task 1 $t_v = 250$ms, Task 2 $t_v = 500$ms, Task 3 $t_v = 300$ms
\vspace*{-1.75em}
\begin{center}
	\raisebox{-.5\height}{\includegraphics[scale=0.135]{images/scheduling_beispiel.png}}
\end{center}

\subsection{Schedulingstrategien}
\vspace*{-1.75em}
$\circ$ \textbf{First Come First Serve}\\
\hspace*{1em}- Prozesse werden entsprechend ihres Erzeugungspunktes in die Warteschlange eingereiht\\
\hspace*{1em}- Jeder Prozess darf \textbf{bis zu seinem Ende} laufen (außer er blockiert zwischendurch)\\
\hspace*{1em}- Wenn ein Prozess \textit{bereit} wird, fügt man ihn entsprechend seines Erzeugungspunktes in die Warteschlange ein\\
\hspace*{1em}$\Rightarrow$ \textbf{Nicht} für Realzeitsysteme geeignet, da ein Prozess alle anderen blockieren kann
\vspace*{-1.75em}
\begin{center}
	\raisebox{-.5\height}{\includegraphics[scale=0.165]{images/first_come_first_serve.png}}
\end{center}

\newpage

$\circ$ \textbf{Round Robin Scheduling}\\
\hspace*{1em}- Prozesse in Warteschlange einreihen, jeder erhält Zeitscheibe (\textit{Quantum})\\
\hspace*{1em}- Nach Ablauf seines Quantums, wird einem noch aktiven Prozess die CPU entzogen und er wird am Ende\\
\hspace*{1em}\hspace*{1em}der Warteschlange eingereiht\\
\hspace*{1em}- Anschließend erhält der nächste Prozess in der Warteschlange die CPU\\
\hspace*{1em}- Abwägen des Quantums (lange Verzögerungszeiten vs. vernünftiges Verhältnis zu Kontextwechsel)\\
\hspace*{1em}- Im dynamischen Scheduling Abarbeitungszeitpunkt eines Prozesses nicht vorhersagbar $\Rightarrow$ \textbf{Nicht} für Realzeitsysteme geeignet\\
\hspace*{1em}- Im statischen Scheduling sind Zeitscheiben fest, wenn Anzahl Prozesse von vornherein bekannt, eignet es sich eventuell
\vspace*{-1.75em}
\begin{center}
	\raisebox{-.5\height}{\includegraphics[scale=0.21]{images/round_robin.png}}
\end{center}

$\circ$ \textbf{Prioritätengesteuertes Scheduling}\\
\hspace*{1em}- Jeder Prozess erhält Priorität, Prozess mit höchster Priorität erhält CPU\\
\hspace*{1em}- Für Realzeitsysteme \textbf{geeignet} - kritisch: Wahl der Prioritäten
\vspace*{-1.75em}
\begin{center}
	\raisebox{-.5\height}{\includegraphics[scale=0.21]{images/prioritaeten_scheduling.png}}
\end{center}

$\circ$ \textbf{Deadline-Scheduling}\\
\hspace*{1em}- Der Prozess mit der am nächsten gelegenen Deadline (\textbf{maximal zulässige Reaktionoszeit}) erhält die CPU\\
\hspace*{1em}- Prozesse müssen dem Scheduler ihre Deadline bekannt geben (ggf. nicht immer bekannt)\\
\hspace*{1em}- Findet einen Weg zur Einhaltung der maximalen Reaktionszeit (falls es einen gibt), d.h. es ist für Realzeitsysteme \textbf{geeignet}
\vspace*{-1.75em}
\begin{center}
	\raisebox{-.5\height}{\includegraphics[scale=0.21]{images/deadline_scheduling.png}}
\end{center}

$\circ$ \textbf{POSIX 1003.1b}\\
\hspace*{1em}- Prioritätengesteuert, innerhalb einer Prioritätsebene scheduling nach: \textit{FIFO/Round Robin}\\
\hspace*{1em}- \textbf{FIFO} geeigneter bei Prozessen mit kurzer Verarbeitungszeit (I/O intensiv), \textbf{Round Robin} bei langer Verarbeitungszeit (CPU intensiv)\\
\hspace*{1em}- Priorität 0 ist niedrigste Priorität\\
\hspace*{1em}- Prioritätenzuteilung nach \textbf{Rate Monotonic} (je kürzer Prozesszeit $t_p$ desto kleiner im Regelfall die Verarbeitungszeit $t_v$ und\\
\hspace*{1em}\hspace*{1em}desto höher die Priorität) - CPU intensive bekommen niedrige, I/O intensive hohe Priorität
\vspace*{-1.75em}
\begin{center}
	\raisebox{-.5\height}{\includegraphics[scale=0.11]{images/posix_scheduling.png}}
\end{center}

\newpage

$\circ$ \textbf{POSIX 1003.1b Sporadic Scheduling}\\
\hspace*{1em}- \textbf{Erkennt Probleme:} Nicht alle Tasks sind zyklisch, \textbf{Deadlines sagen nichts über Auslastung aus} (beliebige Prozesszeiten möglich),\\
\hspace*{1em}\hspace*{1em}nur mit Prioritäten kein Echtzeitnachweis möglich (bis auf triviale Fälle)\\
\hspace*{1em}- \textbf{Hat Lösungen:} Tasks mit unbekannter Prozesszeit (\textit{azyklisch} / \textit{gelegentlich}) als zyklischen Task modellieren, bei dem im Falle\\
\hspace*{1em}\hspace*{1em}einer \textit{Prozesszeitverletzung} \textbf{die Priorität herabgesetzt wird}, zyklische Tasks erhalten \textbf{minimale} Prozess- und Verarbeitungszeit\\
\hspace*{1em}- Sporadische Tasks werden definiert mit: \textbf{Priorität}, (angenommener) \textbf{Prozesszeit} (\textit{Replenishment Period}),\\
\hspace*{1em}\hspace*{1em}(erlaubter) \textbf{Verarbeitungszeit pro Takt} (\textit{C}), und \textit{Zurueckstufungsprioritaet}\\
\hspace*{1em}- System begrenzt Anzahl an \textit{Replenishments} um Systemoverhead niedrig zu halten\\
\hspace*{1em}- Sporadische Tasks, die erlaubtes Kontingent überschreiten, beeinflussen das Gesamtsystem \textbf{nicht negativ}\\
\hspace*{1em}- Alle Prozesse sind \textit{zyklische Prozesse} $\Rightarrow$ Echtzeitnachweis ganz einfach mit \textit{Hinreichender Schedulingbedingung}
\vspace*{-1.75em}
\begin{center}
	\raisebox{-.5\height}{\includegraphics[scale=0.175]{images/sporadic_scheduling.png}}
\end{center}




\end{document}