%http://de.wikipedia.org/wiki/Hilfe:TeX#Sonderzeichen_in_TeX
%http://www.kubieziel.de/computer/latex-tutorial.html
%http://www.math.uiuc.edu/~hildebr/tex/course/intro2.html
%http://en.wikibooks.org/wiki/LaTeX/Packages/Listings
%Immer document.tex oder main.tex nennen!
%http://latex.mschroeder.net/
%http://stackoverflow.com/questions/741985/latex-source-code-listing-like-in-professional-book
%http://amath.colorado.edu/documentation/LaTeX/reference/faq/bibstyles.pdf
%ftp://tug.ctan.org/pub/tex-archive/info/l2tabu/german/l2tabu.pdf
%http://amath.colorado.edu/documentation/LaTeX/reference/faq/bibstyles.html#styles
%http://www.bibtex.org/SpecialSymbols/de/
%http://amath.colorado.edu/documentation/LaTeX/reference/faq/bibstyles.html#styles
%http://www.bibtex.org/SpecialSymbols/de/
%http://en.wikipedia.org/wiki/Help:Displaying_a_formula
%mit "\input{datei}" wird die Datei "datei.tex" direkt an dieser Stelle eingefügt

\documentclass[
% *** Papiergröße und Seitenteilung ***
	openany,
	german,
	paper=a4,				%A4
					%Bindung links, aufgeschlagen von rechts
	DIV=15,					%Seitenteilung (Anzahl der Teile). Einfach mal damit spielen
							%8..15
	BCOR=-1cm,				%Binderand auf der Innenseite für die Buchbindung
% *** Formatierung/Schriftgröße/Kopf/Fußzeilenoptionen
	8pt,					%Schriftgröße 12pt
	parskip,				%kann mit einer Länge versehen werden um die Absatzgröße
							%einzustellen	
	headsepline,			%Kopfzeile über jeder Seite anlegen
	cleardoublepage=empty,	%Füllseiten sind auch wirklich "leer", also auch ohne
							%Seitennummerierung
	%,chapterprefix
% *** Einträge im Inhaltsverzeichnis (TOC) definieren ***
	bibtotoc,				%Literaturverz/Referenzen
	]{scrreprt}				%KOMA-Vorlage scrrprt

% *** KOMA-Seitenstil Kopfzeilen/Fußzeilen! ***
\setkomafont{disposition}{\rmfamily}
\usepackage{scrpage2} 		%KOMA-Seitenstil
\pagestyle{scrheadings} 	%Seitenstile von scrpage2 {KOMA} aktivieren
\automark[section]{chapter}	%Kapitel innen, Unterkapitel rechts
\clearscrheadings 			%Alle Markierungen auf den Seiten löschen
\ihead{}					%Seitenkopf innen (Bei D.seite l.Seite: r.o. und bei r.Seite:l.o)
\chead{}					%Seitenkopf mitte
\ohead{\headmark}			%Seitenkopf außen 
\ifoot{}					%Seitenfuß innen
\cfoot{}					%Seitenfuß mitte
\ofoot{\pagemark}			%Seitenfuß außen
\setlength{\headheight}{1.1\baselineskip}	%Höhe des reservierten Platzes am Seitenkopf

	
%******************************
%      Sprache und Schrift 
%******************************	
%alles für deutsche Eingabe (sonst keine Umlaute im Sourcecode möglich)   
\usepackage[latin1]{inputenc}
%\usepackage[utf8]{inputenc}
\usepackage[english,ngerman]{babel} 
\usepackage[T1]{fontenc} 	
\usepackage{lmodern}		%bessere Schrift		
%  **  Absätze  **
\parindent 0pt				%Absätze nicht von links einrücken
%Größe dynamisch anpassen, so dass auf die Seite mehr Text geht
%oder aufgeweitet wird, so dass eine angefangene Seite besser gefüllt wird
%\usepackage{setspace}		
\usepackage[onehalfspacing]{setspace}

%******************************
% ALTE SPRACHEN
%******************************
%\usepackage{ibycus4}	%altgriechisch
%\usepackage{etex}
%\usepackage{cjhebrew}		%hebräisch
%\usepackage[english]{betababel}

%\usepackage{palatino}
%\usepackage{latexsym}
%\usepackage{multirow}
%\usepackage{graphicx}


%*********************************
%	Pakete für Index/Glossar/Mathe/...
%*********************************
% ** Mathe/Formeln **
\usepackage{amsmath} 		%TeX-Mathe ermöglichen
% ** Inhaltsverzeichnis **
\usepackage{makeidx}		%wird durch \makeindex eingeleitet und
							%\printindex ausgeführt
\makeindex
% ** Bilder/Grafiken einbinden **
\usepackage{graphicx}		%Graphiken aller Art einbinden, auch eps
\usepackage{float} 			%platziert grafiken besser
% ** Links im PDF werden anklickbar **
\usepackage{hyperref}
% ** Glossar für Begriffsdefinitionen wird erstellt **
\usepackage{nomencl}		%Nomenklatur-Paket für das Glossar verwenden 
\makenomenclature			%wird durch /makenomenclature eingeleitet und mit
							%/printnomenclature ausgeführt
% ** Listings ** ->Sourcecode vorformatiert zitieren -> z Zt auf C++ eingestellt
\usepackage{listings}		%Code-Listings erlauben
\usepackage{color}			%ermöglicht Farbvorgaben, z.B. bei den Listings
\usepackage{courier}
\usepackage{caption}
\usepackage{subfig}
\usepackage{makecell}
\usepackage{titlesec}
\usepackage[default]{gfsneohellenic}
\usepackage{tikz}
\usepackage{tabularx}

%******************
%  RESERVIERT
%******************
%\usepackage{mparhack}		%evtl. notwendig, wenn Ränder buggy
%\input{Kapitel/Zusatz}	%andere Textdateien includieren

%********************************************************
%	Titel usw., auch für das PDF
%********************************************************
\title{Vorlage für eine Bachelorarbeit mit LaTeX}
\author{René Bauer}
\date{9. Mai 2011}
% ** Einträge für das erzeugte PDF **
\hypersetup{
pdfauthor = {René Bauer},
pdftitle = {Vorlage für eine Arbeit mit LaTeX}, 
pdfsubject = {Steuerungsoptimierung},
pdfkeywords = {TeX, LaTeX, pdflatex, Bachelorarbeit, Bachelorthesis, Diplomarbeit},
pdfcreator = {LaTeX with hyperref package},
pdfproducer = {dvips + ps2pdf}	%eigentlich ist es pdflatex
}
\lstset{language=C++,
	basicstyle=\ttfamily,
	keywordstyle=\color{blue}\ttfamily,
	stringstyle=\color{red}\ttfamily,
	commentstyle=\color{green}\ttfamily,
	numbers=none,
	morecomment=[l][\color{magenta}]{\#}
}


\titleformat{\chapter}[display]
{\normalfont\huge}{}{10pt}{\Large}
\titlespacing{\chapter}{0pt}{-125pt}{0pt}

\titleformat{\section}[display]
{\normalfont\huge}{}{-50pt}{\large}

\titleformat{\subsection}[display]
{\normalfont\huge}{}{-50pt}{\large}

%*********************************************
%	Fußnoten durchgehend nummerieren
%*********************************************
% - normalerweise wird je Seite oder Kapitel neu gezählt
\usepackage{chngcntr} 
\counterwithout{footnote}{chapter}

%*********************************************
% Überschriften usw neu benennen
%*********************************************
% hier ist nicht die Namensgebung und Aufnahme der
% Begriffsdefinitionen, hierfür bitte unten nachschauen!
%\renewcommand{\contentsname}{Table of contents}
%\renewcommand{\listfigurename}{List of figures}
%\renewcommand{\figurename}{Figure}
%\renewcommand{\tablename}{Table}
%\renewcommand{\listtablename}{List of tables}

%************************************************
%    HIER BEGINNT DAS EIGENTLICHE DOKUMENT
%************************************************
\begin{document}

%**************************************************************
%   unbedingt eine Seite für die spätere Bindung frei lassen!
%**************************************************************
%\newpage

%******************************************************
%                     Titelblatt
%******************************************************

\chapter{Embedded Systems}
\section{Einführung}
\subsection{Eingebettetes System}
\vspace*{-1.7em}
\begin{tabular}{lc}
	\raisebox{-.5\height}{\includegraphics[scale=0.315]{images/eingebettetes_system.png}} & \makecell[l]{
		$\circ$ integrierte, elektronische Schaltung mit spezifischer Aufgabe,\\
		\hspace*{1em}mit der ein Benutzer nur indirekt in Verbindung kommt\\
		$\circ$ Teil eines Gesamtsystems mit stark beschränkten Ressourcen,\\
		\hspace*{1em}bestehend aus Hard- und Software (teilweise ohne Betriebssystem)\\
		$\circ$ HW/SW-Codedesign z.B. mit \textit{VHDL},\\
		\hspace*{1em}allgemein \textit{tool}- bzw. \textit{modellbasierter} Entwurf\\
		$\circ$ \textit{75 \%} verwenden ein Betriebssystem (Tendenz steigend)\\
		\hspace*{1em}- \textit{25 \%} mit \textit{Main-Loop}
	}
\end{tabular}\\

\begin{tabular}{lc}
	\makecell[l]{
		$\circ$ Ist eine Kombination aus Hard- und Softwarekomponenten, die in einen technischen Kontext\\
		\hspace*{1em}zur \textit{Steuerung}, \textit{Regelung} und \textit{Überwachung} eines Systems eingebunden sind\\
		$\circ$ Es verrichtet vordefinierte Aufgaben, oftmals mit \textit{Echtzeitberechnungs}-Anforderungen\\
		$\circ$ \textbf{Speicherprogrammierbare Steuerung} (SPS): Verwendet zur Fabrikautomatisierung, Verkehrsleitung\\
		$\circ$ \textbf{Standardarchitektur} auf einem PC: Preiswerte Hardware (allerdings oft nicht \textit{industrietauglich})\\
		\hspace*{1em}preiswerte Software, häufig ohne \textit{Echtzeitfaehigkeit}\\
		$\circ$ \textbf{Industrie-PC}: Unterstützt Echtzeitbetriebssysteme
	} & \raisebox{-.5\height}{\includegraphics[scale=0.315]{images/prozessankopplung.png}}
\end{tabular}

\vspace*{-.5em}
\subsection{Definition: \textit{Technischer Prozess}}
\vspace*{-1.7em}
$\circ$ Prozess, in dem Zustandsgrößen durch \textit{technische} Hilfsmittel festgestellt und beeinflusst werden\\
\hspace*{1em}- \textit{Prozess} definiert als Gesamtheit von aufeinander einwirkenden Vorgängen in einem System, durch die Information verändert wird\\
$\circ$ \textit{Sensoren} (z.B. Thermometer, Kamera, Mikrofon) erfassen Zustandsgrößen, \textit{Aktoren} (z.B. Motoren, Relais, Ventile) beeinflussen sie

\vspace*{-.75em}
\subsection{Klassifikation: \textit{Technischer Prozess}}
\vspace*{-1.7em}
$\circ$ \textbf{Fließprozess (Regler):} physikalische Größe mit stückweise kontinuierlichem Wertebereich,\\
\hspace*{1em}ablaufende Vorgänge sind zeit- und ortsabhängig, z.B. chemische Reaktoren, Energieerzeugung in Kraftwerken\\
$\circ$ \textbf{Folgeprozess (State Machine):} Binäre, diskrete Informationselemente werden gemeldet oder ausgelöst,\\
\hspace*{1em}z.B. Ampel- oder Aufzugsteuerung\\
$\circ$ \textbf{Stückprozess (Datenbank):} Informationselemente werden einzeln identifizierbaren Objekten (Stücken) zugeordnet\\
\hspace*{1em}z.B. Transport- oder Ladevorgänge, Fertigung

\vspace*{-.75em}
\subsection{Definition: \textit{Rechenprozess}}
\vspace*{-1.7em}
$\circ$ \textit{Task} als Instanz zur dynamischen Abarbeitung eines Programms zur Berechnung von Ausgabewerten aus Eingabewerten über\\
\hspace*{1em}Umformen, Transportieren oder Speichern von Information

\vspace*{-.75em}
\subsection{Definition: \textit{Kognitiver Prozess}}
\vspace*{-1.7em}
\begin{tabular}{lc}
	\raisebox{-.5\height}{\includegraphics[scale=0.175]{images/kognitiver_prozess.png}} & \makecell[l]{
		$\circ$ Umformen, transportieren oder verarbeiten von Information im menschlichen Bediener\\
		$\circ$ Einflussnahme des Bedieners auf den Rechenprozess über \textit{Man Machine Interface} (MMI)
	}
\end{tabular}

\vspace*{-.75em}
\subsection{Definition: \textit{Steuerungssystem}}
\vspace*{-1.7em}
$\circ$ Umfasst zur Steuerung erforderliche Rechenprozesse sowie deren Hard- bzw. Software\\
$\circ$ Aufgaben:\\
\hspace*{1em}- Erfassen von Zustandsgrößen\\
\hspace*{1em}- Koordinaten \& Überwachung der Prozessabläufe

\vspace*{-.75em}
\subsection{Definition: \textit{Steuerung} und \textit{Regelung}}
\vspace*{-1.7em}
$\circ$ \textbf{Steuerung:} Kein geschlossener \textit{Regelkreis}, Rechenprozess reagiert nicht auf sich ändernde Sensorwerte im technischen Prozess\\
$\circ$ \textbf{Regelung:} Geschlossener \textit{Regelkreis}, Sensor- bzw. Messwerte werden verwendet, um Stellgrößen daraus zu berechnen

\newpage

\vspace*{-3.0em}
\subsection{Self-Hosted-Entwicklung}
\vspace*{-1.7em}
$\circ$ Entwicklungsumgebung und Zielsystem sind identisch (\textit{so wie wir es alle kennen})

\vspace*{-0.5em}
\subsection{Host-Target-Entwicklung}
\vspace*{-1.7em}
$\circ$ \textit{Self-Hosted-Entwicklung} oft nicht möglich da Hardware proprietär oder zu leistungsschwach für Entwicklungsumgebung\\
\begin{tabular}{lc}
	\raisebox{-.5\height}{\includegraphics[scale=0.225]{images/host_target_entwicklung.png}} & \makecell[l]{
		$\circ$ \textbf{Host:} Entwicklungsrechner, enthält \textit{Cross-Compiler}, \textit{Remote-Debugger}, \textit{Target-}Libraries und -Betriebssystem\\
		\hspace*{1em}- \textit{Cross-Compiler:} Erzeugt \textit{Image}, dass eigentliche Applikation sowie\\
		\hspace*{1em}\hspace*{1em}Betriebssystem- und Laufzeitkomponenten + \textit{Startupcode} enthält\\
		\hspace*{1em}- \textit{Remote-Debugger:} Auf dem Host läuft GUI mit \textit{Debug-Info}, über \textit{JTAG} etc. sieht man\\
		\hspace*{1em}\hspace*{1em}den Systemzustand des Targets (\textit{Stack}, \textit{Variablen}belegung) an gewählten \textit{Breakpoints}\\
		\hspace*{1em}- \textit{Ohne} Remote-Debugger: Konsolenausgaben per \textit{printf}, \textit{LED}s blinken lassen\\
		$\circ$ \textbf{Schnittstelle:} Zum \textit{Downloaden} der Applikation auf das \textit{Target} oder fürs \textit{Debugging},\\
		\hspace*{1em}verschiedenste Variationen möglich (z.B. \textit{Ethernet}, \textit{USB}, \textit{JTAG}, \textit{Flash}, ...)\\
		$\circ$ \textbf{Target:} System, für das entwickelt wird\\
		\hspace*{1em}- \textit{Boot-Monitor:} Programm auf dem Target, über das Software geladen und gestartet werden kann,\\
		\hspace*{1em}\hspace*{1em}erfolgt über ähnliche Schnittstellen wie die \textit{Host-Target}-Entwicklung an sich
	}
\end{tabular}

\vspace*{-1.7em}
\subsubsection{Softwareentwicklung in einem \textit{Host-Target} System}
\vspace*{-1.7em}
\begin{tabular}{lc}
	\raisebox{-.5\height}{\includegraphics[scale=0.275]{images/entwicklung_host_target.png}} & \makecell[l]{
		$\circ$ \textbf{Object File:} Symboltabelle\\
		$\circ$ \textbf{Linker:} Symbol-Auflösung und \textit{Relocation}\\
		$\circ$ \textbf{Executable File:} Code \& Daten zur Ausführung, Umsetzung auf virtuellen Speicher\\
		$\circ$ \textbf{Shared object file:} Code und Daten zum (dynamischen) linken mit anderen \textit{object files}\\
		$\circ$ \textbf{Relocatable file:} Code und Daten zum linken mit anderen \textit{object files} um Executable\\
		\hspace*{1em}zu erstellen\\
		$\circ$ \textbf{Dynamic Linker:} Laden von \textit{shared} Libraries
	}
\end{tabular}

\vspace*{-1.7em}
\subsubsection{Tools: \textit{Kernel-Tracer}}
\vspace*{-1.7em}
$\circ$ Zeigt \textit{Signale}, \textit{Task-Zustaende}, \textit{Semaphoren}, \textit{Interrupts}

\vspace*{-1.7em}
\subsubsection{Tools: \textit{Stack-Monitor}}
\vspace*{-1.7em}
\text{$\circ$ Zeigt maximal verfügbarer \textit{Stack} pro \textit{Task}, aktuelle Auslastung und maximale je gemessene Auslastung (\textit{Hochwassermarke}) des Stacks}

\vspace*{-1.7em}
\subsubsection{Weitere Tools}
\vspace*{-1.7em}
$\circ$ Anzeige der Speicherbelegung und \textit{Auslastung} der \textit{CPU}, \textit{Memory-Leak-Detection}, \textit{Code-Coverage}

\newpage

\vspace*{-2.9em}
\section{Echtzeitbetrieb}
\vspace*{-.5em}
\subsection{Kriterien für Echtzeitsysteme}
\vspace*{-1.75em}
\begin{tabular}{lc}
	\raisebox{-.5\height}{
		\begin{tikzpicture}[scale=0.67]
			\coordinate (R) at (0,0);
			\coordinate (B) at (3.5,0.01);
			\coordinate (C) at (4.1,0.01);
			
			\draw[->] (-.5,0) -- (4.2,0) node[right] {$t$};
			\draw[->] (0,-.5) -- (0,4.2) node[above] {$Auslastung$};
			\draw[-, line width=0.25mm]  (3,-.5) -- (3,4);
			\node[] at (4.67, -.5) {Echtzeitschranke};
			
			\draw[-] (R) to[out=60,in=130, distance=3cm ] (B);
			\node[] at (1.75,2.2) {Schneller PC};
			
			\draw[-] (R) to[out=40,in=140, distance=3cm ] (C);
			\node[] at (5.25,0.75) {Langsamer PC};
		\end{tikzpicture}
		} & \makecell[l]{
		$\circ$ Schnelligkeit bzw. Geschwindigkeit ist \textbf{nicht} wichtig im Kontext einer harten Echtzeitschranke\\
		\hspace*{1em}ein schnellerer PC ist zwar häufiger vor der Schranke fertig, aber eben auch nicht zu 100\%\\
		$\circ$ Wichtig dagegen sind:\\
		\hspace*{1em}- Pünktlichkeit (\textit{Ober- und Untergrenze}) bzw. Rechtzeitigkeit (\textit{Nur Obergrenze}) (\textit{timeliness})\\
		\hspace*{1em}- Verfügbarkeit\\
		\hspace*{1em}- Determinismus (bei gleicher Eingabe im gleichen Zustand liefert das System immer die\\
		\hspace*{1em}\hspace*{1em}gleiche Ausgabe)\\
		$\circ$ Verletzungen von Zeitbedingungen ggf. katastrophal (fristgerechte Bearbeitung von Anforderungen\\
		\hspace*{1em}aus einem technischen Prozess)
	}
\end{tabular}

\vspace*{-.5em}
\subsection{Vorbedingungen für Echtzeitbetrieb}
\vspace*{-1.7em}
$\circ$ Verarbeitungszeit von Aufgaben berücksichtigen, bei mehreren Aufgaben Reihenfolge der Abarbeitung planen\\
$\circ$ Reihenfolge entscheidend für fristgerechte Ergebnisse\\
$\circ$ Priorität von Aufgaben gemäß ihrer Wichtigkeit als Planungsgrundlage\\
$\circ$ Unterbrechung einer Aufgabe muss durch einen Prozess zur Bearbeitung höher-priorer Aufgaben möglich sein\\
\hspace*{1em}$\Rightarrow$ Formaler Rahmen zum Nachweis schritthaltender Verarbeitung

\vspace*{-1em}
\subsection{Echtzeitbedingung: Auslastung}
\vspace*{-1.7em}
\begin{tabular}{lc}
	\raisebox{-.5\height}{\includegraphics[scale=0.325]{images/auslastung.png}} & \makecell[l]{
		$\circ$ $t_V$ := Verarbeitungszeit\\
		$\circ$ $t_P$ := Prozesszeit, Abstand zwischen zwei Anforderungen (\textit{Jobs})\\
		\hspace*{1em}desselben Typs, wenn $t_P$ konstant handelt es sich um einen\\
		\hspace*{1em}\textit{zyklischen} bzw. \textit{periodischen} Prozess\\
		$\circ$ $\rho = \frac{t_V}{t_P}$ := Auslastung\\
		\hspace*{1em}- $\rho_A = \frac{t_{VA}}{t_{PA}}$\\
		\hspace*{1em}- $\rho_B = \frac{t_{VB}}{t_{PB}}$\\
		\hspace*{1em}- $\rho_{A+B} = \frac{t_{VA}}{t_{PA}} + \frac{t_{VB}}{t_{PB}}$\\
		$\circ$ $\rho = \sum_{i = 0}^{n}\frac{t_Vi}{t_Pi}$ := Gesamtauslastung bei $n$ Prozessen
	}
\end{tabular}
$\circ$ \textbf{1. \textit{Echtzeitbedingung:}} Gesamtauslastung aller Prozesse $\leq$ 1 $\Leftrightarrow$ $\rho = \sum_{i = 0}^{n}\frac{t_Vi}{t_Pi} \leq 1$

\vspace*{-1.7em}
\subsubsection{Art von Rechenprozessen}
\vspace*{-1.7em}
$\circ$ \textit{zyklisch:} konstanter Abstand zwischen zwei Anforderungen\\
$\circ$ \textit{azyklisch:} Keine Untergrenze zwischen zwei Nachrichten, kommen beliebig (\textit{gefaehrlich})\\
$\circ$ \textit{sporadisch:} ähnlich wie \textit{azyklisch} aber mit Untergrenze zwischen zwei Nachrichten (z.B. \textit{Netzwerktreiber})

\vspace*{-1em}
\subsection{Echtzeitbedingung: Pünktlichkeit}
\vspace*{-1.7em}
\begin{tabular}{lc}
	\raisebox{-.5\height}{\includegraphics[scale=0.325]{images/puenktlich.png}} & \makecell[l]{
		$\circ$ Aufgabe darf nicht vor spezifizierten Zeitpunkt $t_{Zmin}$ erledigt sein(meist unwichtig oder \textit{trivial})\\
		$\circ$ Aufgabe muss spätestens bis Zeitpunkt $t_{Zmax}$ erledigt sein (Rechtzeitigkeit)\\
		$\circ$ Verbleibende Reaktionszeit: $t_R = t_V + t_W$ (Verarbeitungszeit + Wartezeit)\\
		\hspace*{1em}\textit{Wartezeit} := Zeit, bis Rechenkern frei ist
	}
\end{tabular}
$\circ$ \textbf{2. \textit{Echtzeitbedingung:}} Um Aufgaben rechtzeitig zu erledigen, muss die Reaktionszeit zwischen der minimal\\
\hspace*{1em}und maximal zulässigen Reaktionszeit liegen: $t_{Zmin} \leq t_{Rmin} \leq t_R \leq t_{Rmax} \leq t_{Zmax}$

\newpage

\vspace*{-2.5em}
\subsection{Harte und weiche Echtzeit}
\vspace*{-1.7em}
\begin{tabular}{lc}
	\raisebox{-.5\height}{
		\begin{tikzpicture}[scale=0.75]
			\coordinate (A) at (1,0);
			\coordinate (B) at (0,1);
			\coordinate (C) at (3,0);
			\coordinate (D) at (4,1);
			\coordinate (E) at (1,3);
			\coordinate (F) at (3,3);
			\coordinate (G) at (.25,3);
			\coordinate (H) at (3.75,3);
			
			\draw[->] (-.5,0) -- (4.2,0) node[right] {$t$};
			\draw[->] (0,-.5) -- (0,4.2) node[above] {$Kosten$};
			
			\draw[-] (A) node[below] {$t_{Zmin}$} -- (B);
			\draw[-] (C) -- (D)node[right] {Weiche Echtzeit};
			
			\draw[-, dotted] (A) -- (E);
			\draw[-, dotted] (C) node[below] {$t_{Zmax}$} -- (F) node[left] {$Deadline$};
			
			\draw[-] (A) to[out=95, in=-60] (G);
			\draw[-] (C) to[out=85, in=-120] (H) node[right] {Harte Echtzeit};
		\end{tikzpicture}
	} & \makecell[l]{
		$\circ$ \textit{Harte} Echtzeit: Verletzung der Rechtzeitigkeit hat \textit{katastrophale} Folgen\\
		\hspace*{1em}(z.B. Airbag, Herzschrittmacher)\\
		$\circ$ \textit{Weiche} Echtzeit: Schlechteres Ergebnis (z.B. \textit{ruckelnde} Videowiedergabe, GPS-Latenz)\\
		\hspace*{1em}$\Rightarrow$ Häufig \textit{Graubereich}\\
		$\circ$ \textit{Kostenfunktion:} Kosten \textit{explodieren} bei Überschreitung der Echtzeitschranke (\textit{Deadline})\\
		\hspace*{1em}im Falle von Harter Echtzeit, bei Weicher Echtzeit steigen Kosten nur \textit{linear} an
	}
\end{tabular}

\vspace*{-1em}
\begin{tabular}{lc}
	\makecell[l]{
		$\circ$ \textit{Nutzenfunktion:} Ergebnisse außerhalb des Intervalls $[t_{Zmin}, t_{Zmax}]$ haben bei Harter Echtzeit\\
		\hspace*{1em}nahezu \textit{keinen} Nutzen mehr, bei Weicher Echtzeit ungefähr \textit{lineare} Ab- bzw. Zunahme
	} &
	\raisebox{-.5\height}{
		\begin{tikzpicture}[scale=0.75]
			\coordinate (A) at (0,0.1);
			\coordinate (B) at (1,0.1);
			\coordinate (C) at (1,3);
			\coordinate (D) at (3,0.1);
			\coordinate (E) at (3,3);
			\coordinate (F) at (4,0.1);
			
			\draw[->] (-.5,0) -- (4.2,0) node[right] {$t$};
			\draw[->] (0,-.5) -- (0,4.2) node[above] {$Nutzen$};
			
			\draw[-, line width=0.275mm] (A) -- (B) node[below] {$t_{Zmin}$};
			
			\draw[-, line width=0.275mm] (B) -- (C);
			\draw[-, line width=0.275mm] (D) node[below] {$t_{Zmax}$} -- (E) node[left] {$Deadline$};
		
			\draw[-, line width=0.275mm] (D) -- (F);
			
			\draw[-] (A) to[out=53, in=-95] (C);
			\draw[-] (E) to[out=275, in=127] (F);

			
			\node[rotate=90] at (.3, 2.125) {Weiche Echtzeit};
			\node[rotate=90] at (3.75, 2.125) {Weiche Echtzeit};
			\node[rotate=45] at (2, 1.25) {Harte Echtzeit};
			
		\end{tikzpicture}
	}

\end{tabular}


\newpage


\vspace*{-2.5em}
\section{Echtzeitbetriebssysteme}
\vspace*{-.5em}
\subsection{Aufgaben und Anforderungen}
\vspace*{-1.7em}
$\circ$ Steuern und Überwachen: Ausführung der Benutzerprogramme \& Verteilung der Betriebsmittel (Speicher, Prozessor, Dateien)\\
$\circ$ Stellt dem Benutzer die Sicht einer einfacher als die Hardware zu bedienenden \textit{virtuellen Maschine} zur Verfügung\\
\hspace*{1em}- Aus Sicht des Benutzers steht der Rechner ihm allein zur Verfügung\\
\hspace*{1em}- Einfacher, standardisierter Zugriff auf \textit{Ressourcen} (Speicher, Geräte, Dateien per Gerätetreiber, Dateisystem, Speichermanagement)\\
$\circ$ \textbf{Zeitverhalten}\\
\hspace*{1em}- Schnelligkeit (bei einem \textit{RTOS} insbesondere Realisierung kurzer Antwortzeiten)\\
\hspace*{1em}- Zeitlicher Determinismus (Speicherverwaltung und Garbage Collection sind problematisch)\\
\hspace*{1em}\hspace*{1em}$\star$ Scheduling, IPC und Synchronisation\\
\hspace*{1em}\hspace*{1em}$\star$ Angabe und Einhalten von Zeitbedingungen, Bereitstellen von \textit{Zeitdiensten}\\
$\circ$ \textbf{Geringer Ressourcenverbrauch}\\
\hspace*{1em}- Hauptspeicher \& Prozessorzeit\\
$\circ$ \textbf{Zuverlässigkeit \& Stabilität}\\
\hspace*{1em}- Programmfehler dürfen Betriebssystem und andere Programme \textit{nicht} beeinflussen\\
\hspace*{1em}- Linux: Treiber \& Kernelmodule laufen im \textit{Kernel}-Adressraum\\
\hspace*{1em}- QNX: Mikrokernel-Architektur: sogar Treiber haben \textit{eigenen} Adressraum\\
$\circ$ \textbf{Sicherheit}\\
\hspace*{1em}- Datei- und Zugangsschutz\\
$\circ$ \textbf{Portabilität, Flexibilität und Kompatibilität von Systemkomponenten}\\
\hspace*{1em}- Erweiterbarkeit, Einhalten von Standard (z.B. \textit{POSIX})\\
\hspace*{1em}- Möglichkeit für andere Betriebssysteme, geschriebene Programme zu portieren (anpassen, übersetzen, ausführen)\\
$\circ$ \textbf{Skalierbarkeit}\\
\hspace*{1em}- Hinzunehmen oder Weglassen von Betriebssystem-Komponenten möglich machen\\
\hspace*{1em}- Geringer Programm- und Datenspeicherbedarf bei kleinen Anwendungen (\textit{Footprint})\\
\hspace*{1em}- Komfort und umfassende Funktionalität bei großen Anwendungen

\vspace*{-.5em}
\subsection{Aufbau und Struktur}
\vspace*{-1.7em}
\begin{tabular}{lc}
	\raisebox{-.5\height}{\includegraphics[scale=0.4]{images/betriebssystemkern.png}} & \makecell[l]{
		$\circ$ Ein \textit{Betriebssystem} besteht aus aufbauenden \textit{Systemkomponenten}\\
		\hspace*{1em}(Dienstprogramme, Werkzeuge) und einem \textit{Betriebssystemkern}\\
		$\circ$ $(1)$: Hardware-\textit{Interrupt}\\
		$\circ$ $(2)$: Software-Interrupt (\textit{Systemcall})\\
		$\circ$ $(3)$: Hardware-Interrupt (während eines Systemcalls)\\
		$\circ$ $(4)$: Hardware-Interrupt (\textit{Scheduler} wird aufgerufen)\\
		$\circ$ $(5)$: Scheduler übergibt CPU einem Task auf \textit{User}-Ebene\\
		$\circ$ Betriebssystem-Dienste werden fast bei jedem Betriebssystem über\\
		\hspace*{1em}Software-Interrupts (\textit{Supervisor Call} / Systemcall) angefordert
	}
\end{tabular}


\newpage


\vspace*{-2.5em}
\subsection{Prozessmanagement}
\vspace*{-1.7em}
\textbf{Unterbrechung \textit{ohne} Betriebssystem}\\
\vspace*{-1.7em}
\begin{tabular}{lc}
	\raisebox{-.5\height}{\includegraphics[scale=0.4]{images/unterbrechung_ohne_bs.png}} & \makecell[l]{
		$\circ$ $(1)$: CPU arbeitet Programm ab\\
		$\circ$ $(2)$: Interrupt während der Programmabarbeitung:\\
		\hspace*{1em}- Abarbeitung des aktuellen Befehls beenden\\
		\hspace*{1em}- Befehlszähler und Registerinhalte auf den Stack legen\\
		\hspace*{1em}- Befehlszähler auf \textit{Interrupt Service Routine} (ISR) legen\\
		$\circ$ $(3)$: \textit{ISR} rettet von ihr benötigte CPU-Register\\
		$\circ$ $(4)$: Eigentliche Interrupt-Behandlung\\
		$\circ$ $(5)$: Gerettete CPU-Register wiederherstellen\\
		$\circ$ $(6)$: Befehl \textit{Return from Interrupt:}\\
		\hspace*{1em}- Auf Stack abgelegte Register (\textit{Flags}, \textit{Befehlszaehler})\\
		\hspace*{1em}\hspace*{1em}wiederherstellen\\
		$\circ$ $(7)$: Normalen Programmablauf fortsetzen\\
		$\circ$ \textit{Softwareinterrupts (Systemcalls):}\\
		\hspace*{1em}- Benutzerprogramme fordern Dienste des Betriebssystems an\\
		$\circ$ \textit{Hardwareinterrupts:}\\
		\hspace*{1em}- Hardwarekomponenten (Systemuhr, HDD) fordern Dienste\\
		\hspace*{1em}\hspace*{1em}des Betriebssystems an
	}
\end{tabular}\\

\textbf{Unterbrechung \textit{mit} präemptivem Scheduling (Multitasking Betriebssystem)}\\
\vspace*{-1em}
\begin{tabular}{lc}
	\raisebox{-.5\height}{\includegraphics[scale=0.4]{images/unterbrechung_mit_bs.png}} & \makecell[l]{
		$\circ$ \textbf{Präemptiv} (bei RTOS): Rechnerkern wird bei\\
		\hspace*{1em}Interrupt der aktuell rechnende Task entzogen\\
		\hspace*{1em}\textit{wenn} höherpriore Task auf Interrupt reagieren muss\\
		\hspace*{1em}\hspace*{1em}- Interrupt zum Kontextwechsel\\
		\hspace*{1em}\hspace*{1em}- Retten des Kontextes des unterbrochenen\\
		\hspace*{1em}\hspace*{1em}\hspace*{1em}Prozesses $j$\\
		\hspace*{1em}\hspace*{1em}- eventuelle Auftragsbearbeitung\\
		\hspace*{1em}\hspace*{1em}- \textit{Scheduler:} Auswahl nächster Rechenprozess $i$\\
		\hspace*{1em}\hspace*{1em}- Kontext von Rechenprozess $i$ laden\\
		\hspace*{1em}\hspace*{1em}- Return zu $PC_i$\\
		\hspace*{1em}Bei Interrupt (z.B. \textit{Timer} oder \textit{I/O}) wird Scheduler\\
		\hspace*{1em}gestartet und zu höher priorem Prozess gewechselt\\
		\hspace*{1em}um obere Reaktionsschranke eines \textit{RTOS} einhalten\\
		\hspace*{1em}zu können (Interrupt-Sperre im \textit{Kernel} so kurz\\
		\hspace*{1em}wie möglich, obere Schranke einhalten \textit{wichtig})\\
		$\circ$ \textbf{Nicht-präemptiv} (normales Betriebssystem):\\
		\hspace*{1em}Scheduling nur bei Systemcall oder zeitgesteuert,\\
		\hspace*{1em}\textit{nicht} bei Interrupt
	}
\end{tabular}\\
\textbf{Task Control Block}\\
$\circ$ Beinhaltet: Priorität, Maschinenzustand (Register, Stack), Task-Zustand, Zeit-Quantum, Verwaltungsdaten für Betriebsmittel\\ \hspace*{1em}(\textit{Filedeskriptor}), Speicherabbildungstabellen für virtuellen Speicher (\textit{Prozessadressraum} $\rightarrow$ \textit{realer} Speicher (Code, Data, Stack))
\hspace*{1em}\hspace*{1em}\begin{lstlisting}[basicstyle=\small]
	char*			name;			/* task name */
	uint			status;			/* status of task */
	uint			priority;		/* task's current priority */
	uint			prioNormal;		/* task's normal priority */
	FUNCPTR			entry;			/* entry point of task */
	struct sigtcb	*pSignalInfo;	/* ptr to signal info for task */
	uint 			taskTicks;		/* total number of ticks */
	uint			taskIncTicks;	/* number of ticks in slice */
	struct __sFile	*taskStdFp[3]; int taskStd[3];	/* stdin, stdout, stderr fps / fds */
	char			**ppEnviron;	/* environment var table */
	int				envTblSize;		/* number of slots in table */
	int				nEnvVarEntries;	/* num env vars used */
	EXC_INFO excInfo; REG_SET regs;		/* exception info & register set */
\end{lstlisting}

\newpage

\textbf{Task-Zustände}\\
\begin{tabular}{lc}
	\raisebox{-.5\height}{\includegraphics[scale=0.375]{images/taskzustaende.png}} & \makecell[l]{
		$\circ$ \textbf{Tasks und Threads:}\\
		\hspace*{1em}- \textit{Leichtgewichtige Prozesse} um Aufwand für \textit{Kontextwechsel} zu minimieren\\
		\hspace*{1em}- Mehrere \textit{Threads} teilen sich fast \textit{kompletten} Task-Kontext\\
		\hspace*{1em}- Lediglich \textit{Stack} (mit Program Counter) und Thread-Status unterschiedlich\\
		\hspace*{1em}- sind effizient zu erzeugen und zu schedulen\\
		\hspace*{1em}- gemeinsamer (\textit{kein} getrennter) Prozessadressraum\\
		\hspace*{1em}- gemeinsame Betriebsmittel wie Files / Devices\\
		\hspace*{1em}- gemeinsamer \textit{globaler Speicher}, oft aus Effizienzgründen verwendet\\
		\includegraphics[scale=0.425]{images/threads.png}\\
	}
\end{tabular}

$\circ$ Thread erzeugen:
\begin{lstlisting}[basicstyle=\small]
#include <stdio.h>
void parent() {
	printf("The parent process has ID %d\n", getpid());
}
void child() {
	printf("The child process has ID %d\n", getpid());
	return;
}
int main(int argc, char **argv) {
	if( fork() != 0) {
		parent();
		wait();
	} else {
		child();
	}
	printf("Exit process %d \n", getpid());
	exit( 0 );
}
\end{lstlisting}

\vspace*{-2em}
$\circ$ $int$ $pthread\_create(pthread\_t *thread, pthread\_attr\_t *attr, void *(*start\_routine)(void*), void *arg)$:\\
\hspace*{1em}- Erzeugt neuen Thread (Einstiegsfunktion $start\_routine$ mit Argument $arg$)\\
\hspace*{1em}- Thread wird nebenläufig mit aufrufenden Thread abgearbeitet\\
\hspace*{1em}\hspace*{1em}- Beenden mit $pthread\_exit$ oder beenden von $start\_routine$\\
\hspace*{1em}- Attribute: \textit{Scheduling} (Art, Parmeter), \textit{Stack} (Größe, Adresse), \textit{JOINABLE} / \textit{DETACHED}\\
\hspace*{1em}\hspace*{1em}- \textit{JOINABLE:} \textit{Thread Control Block} wird solange aufgehoben, bis \textit{JOIN} auf diesen Thread aufgerufen wird\\
\hspace*{1em}\hspace*{1em}- \textit{DETACHED:} \textit{TCB} wird direkt nach Beendigung des Threads weggeworfen\\
$\circ$ $void$ $pthread\_exit(void *retval)$:\\
\hspace*{1em}- Beendigung des Threads mit $retval$\\
\hspace*{1em}- Alternative zu Beenden der $start\_routine$\\
\hspace*{1em}- Cleanup-Handler aufrufen (Ressourcen freigeben (Speicher, Filedeskriptor))\\
$\circ$ $int$ $pthread\_join(pthread\_t thread, void **thread\_return)$:\\
\hspace*{1em}- Aufruf blockiert, bis Thread sich beendet (Ergebnis steht dann in $thread\_return$)\\
$\circ$ $int$ $pthread\_detach(pthread\_t th)$:\\
\hspace*{1em}- Wenn keiner auf Thread wartet, räumt er sich bei Beendigung komplett auf (Thread Deskriptor, Stack)
\end{document}